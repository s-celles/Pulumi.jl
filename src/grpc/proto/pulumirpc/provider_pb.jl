# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-10T11:38:24.502
# original file: /home/scelles-admin/.julia/artifacts/c90104a6945c9e4b68315984a83d31d012ee8abc/pulumi/provider.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export GetMappingResponse, GetMappingRequest, DiffRequest
export var"ParameterizeRequest.ParametersArgs", CheckFailure, ProviderHandshakeRequest
export var"ConstructRequest.PropertyDependencies", ConfigureRequest
export var"CallRequest.ArgumentDependencies", GetMappingsResponse, CreateRequest
export var"CallResponse.ReturnDependencies", var"ParameterizeRequest.ParametersValue"
export ParameterizeResponse, ConfigureResponse, var"ConfigureErrorMissingKeys.MissingKey"
export GetSchemaRequest, var"DiffResponse.DiffChanges", CreateResponse, InvokeRequest
export ProviderHandshakeResponse, View, var"PropertyDiff.Kind"
export var"ConstructRequest.CustomTimeouts", UpdateResponse
export var"CheckRequest.AutonamingOptions.Mode", GetSchemaResponse
export var"ConstructResponse.PropertyDependencies", ErrorResourceInitFailed, ReadResponse
export GetMappingsRequest, var"ConstructRequest.ResourceHooksBinding", InvokeResponse
export CheckResponse, CallRequest, CallResponse, ParameterizeRequest
export ConfigureErrorMissingKeys, UpdateRequest, ReadRequest, DeleteRequest, PropertyDiff
export var"CheckRequest.AutonamingOptions", ConstructResponse, ConstructRequest
export DiffResponse, CheckRequest


struct GetMappingResponse
    provider::String
    data::Vector{UInt8}
end
PB.default_values(::Type{GetMappingResponse}) = (;provider = "", data = UInt8[])
PB.field_numbers(::Type{GetMappingResponse}) = (;provider = 1, data = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetMappingResponse})
    provider = ""
    data = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            provider = PB.decode(d, String)
        elseif field_number == 2
            data = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return GetMappingResponse(provider, data)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetMappingResponse)
    initpos = position(e.io)
    !isempty(x.provider) && PB.encode(e, 1, x.provider)
    !isempty(x.data) && PB.encode(e, 2, x.data)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetMappingResponse)
    encoded_size = 0
    !isempty(x.provider) && (encoded_size += PB._encoded_size(x.provider, 1))
    !isempty(x.data) && (encoded_size += PB._encoded_size(x.data, 2))
    return encoded_size
end

struct GetMappingRequest
    key::String
    provider::String
end
PB.default_values(::Type{GetMappingRequest}) = (;key = "", provider = "")
PB.field_numbers(::Type{GetMappingRequest}) = (;key = 1, provider = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetMappingRequest})
    key = ""
    provider = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key = PB.decode(d, String)
        elseif field_number == 2
            provider = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetMappingRequest(key, provider)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetMappingRequest)
    initpos = position(e.io)
    !isempty(x.key) && PB.encode(e, 1, x.key)
    !isempty(x.provider) && PB.encode(e, 2, x.provider)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetMappingRequest)
    encoded_size = 0
    !isempty(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    !isempty(x.provider) && (encoded_size += PB._encoded_size(x.provider, 2))
    return encoded_size
end

struct DiffRequest
    id::String
    urn::String
    olds::Union{Nothing,google.protobuf.Struct}
    news::Union{Nothing,google.protobuf.Struct}
    ignoreChanges::Vector{String}
    old_inputs::Union{Nothing,google.protobuf.Struct}
    name::String
    var"#type"::String
end
PB.default_values(::Type{DiffRequest}) = (;id = "", urn = "", olds = nothing, news = nothing, ignoreChanges = Vector{String}(), old_inputs = nothing, name = "", var"#type" = "")
PB.field_numbers(::Type{DiffRequest}) = (;id = 1, urn = 2, olds = 3, news = 4, ignoreChanges = 5, old_inputs = 6, name = 7, var"#type" = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DiffRequest})
    id = ""
    urn = ""
    olds = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    news = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    ignoreChanges = PB.BufferedVector{String}()
    old_inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    name = ""
    var"#type" = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            urn = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, olds)
        elseif field_number == 4
            PB.decode!(d, news)
        elseif field_number == 5
            PB.decode!(d, ignoreChanges)
        elseif field_number == 6
            PB.decode!(d, old_inputs)
        elseif field_number == 7
            name = PB.decode(d, String)
        elseif field_number == 8
            var"#type" = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return DiffRequest(id, urn, olds[], news[], ignoreChanges[], old_inputs[], name, var"#type")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DiffRequest)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isempty(x.urn) && PB.encode(e, 2, x.urn)
    !isnothing(x.olds) && PB.encode(e, 3, x.olds)
    !isnothing(x.news) && PB.encode(e, 4, x.news)
    !isempty(x.ignoreChanges) && PB.encode(e, 5, x.ignoreChanges)
    !isnothing(x.old_inputs) && PB.encode(e, 6, x.old_inputs)
    !isempty(x.name) && PB.encode(e, 7, x.name)
    !isempty(x.var"#type") && PB.encode(e, 8, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::DiffRequest)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 2))
    !isnothing(x.olds) && (encoded_size += PB._encoded_size(x.olds, 3))
    !isnothing(x.news) && (encoded_size += PB._encoded_size(x.news, 4))
    !isempty(x.ignoreChanges) && (encoded_size += PB._encoded_size(x.ignoreChanges, 5))
    !isnothing(x.old_inputs) && (encoded_size += PB._encoded_size(x.old_inputs, 6))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 7))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 8))
    return encoded_size
end

struct var"ParameterizeRequest.ParametersArgs"
    args::Vector{String}
end
PB.default_values(::Type{var"ParameterizeRequest.ParametersArgs"}) = (;args = Vector{String}())
PB.field_numbers(::Type{var"ParameterizeRequest.ParametersArgs"}) = (;args = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ParameterizeRequest.ParametersArgs"})
    args = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, args)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ParameterizeRequest.ParametersArgs"(args[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ParameterizeRequest.ParametersArgs")
    initpos = position(e.io)
    !isempty(x.args) && PB.encode(e, 1, x.args)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ParameterizeRequest.ParametersArgs")
    encoded_size = 0
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 1))
    return encoded_size
end

struct CheckFailure
    property::String
    reason::String
end
PB.default_values(::Type{CheckFailure}) = (;property = "", reason = "")
PB.field_numbers(::Type{CheckFailure}) = (;property = 1, reason = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CheckFailure})
    property = ""
    reason = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            property = PB.decode(d, String)
        elseif field_number == 2
            reason = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return CheckFailure(property, reason)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CheckFailure)
    initpos = position(e.io)
    !isempty(x.property) && PB.encode(e, 1, x.property)
    !isempty(x.reason) && PB.encode(e, 2, x.reason)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CheckFailure)
    encoded_size = 0
    !isempty(x.property) && (encoded_size += PB._encoded_size(x.property, 1))
    !isempty(x.reason) && (encoded_size += PB._encoded_size(x.reason, 2))
    return encoded_size
end

struct ProviderHandshakeRequest
    engine_address::String
    root_directory::String
    program_directory::String
    configure_with_urn::Bool
    supports_views::Bool
    supports_refresh_before_update::Bool
    invoke_with_preview::Bool
end
PB.default_values(::Type{ProviderHandshakeRequest}) = (;engine_address = "", root_directory = "", program_directory = "", configure_with_urn = false, supports_views = false, supports_refresh_before_update = false, invoke_with_preview = false)
PB.field_numbers(::Type{ProviderHandshakeRequest}) = (;engine_address = 1, root_directory = 2, program_directory = 3, configure_with_urn = 4, supports_views = 5, supports_refresh_before_update = 6, invoke_with_preview = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ProviderHandshakeRequest})
    engine_address = ""
    root_directory = ""
    program_directory = ""
    configure_with_urn = false
    supports_views = false
    supports_refresh_before_update = false
    invoke_with_preview = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            engine_address = PB.decode(d, String)
        elseif field_number == 2
            root_directory = PB.decode(d, String)
        elseif field_number == 3
            program_directory = PB.decode(d, String)
        elseif field_number == 4
            configure_with_urn = PB.decode(d, Bool)
        elseif field_number == 5
            supports_views = PB.decode(d, Bool)
        elseif field_number == 6
            supports_refresh_before_update = PB.decode(d, Bool)
        elseif field_number == 7
            invoke_with_preview = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return ProviderHandshakeRequest(engine_address, root_directory, program_directory, configure_with_urn, supports_views, supports_refresh_before_update, invoke_with_preview)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ProviderHandshakeRequest)
    initpos = position(e.io)
    !isempty(x.engine_address) && PB.encode(e, 1, x.engine_address)
    !isempty(x.root_directory) && PB.encode(e, 2, x.root_directory)
    !isempty(x.program_directory) && PB.encode(e, 3, x.program_directory)
    x.configure_with_urn != false && PB.encode(e, 4, x.configure_with_urn)
    x.supports_views != false && PB.encode(e, 5, x.supports_views)
    x.supports_refresh_before_update != false && PB.encode(e, 6, x.supports_refresh_before_update)
    x.invoke_with_preview != false && PB.encode(e, 7, x.invoke_with_preview)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ProviderHandshakeRequest)
    encoded_size = 0
    !isempty(x.engine_address) && (encoded_size += PB._encoded_size(x.engine_address, 1))
    !isempty(x.root_directory) && (encoded_size += PB._encoded_size(x.root_directory, 2))
    !isempty(x.program_directory) && (encoded_size += PB._encoded_size(x.program_directory, 3))
    x.configure_with_urn != false && (encoded_size += PB._encoded_size(x.configure_with_urn, 4))
    x.supports_views != false && (encoded_size += PB._encoded_size(x.supports_views, 5))
    x.supports_refresh_before_update != false && (encoded_size += PB._encoded_size(x.supports_refresh_before_update, 6))
    x.invoke_with_preview != false && (encoded_size += PB._encoded_size(x.invoke_with_preview, 7))
    return encoded_size
end

struct var"ConstructRequest.PropertyDependencies"
    urns::Vector{String}
end
PB.default_values(::Type{var"ConstructRequest.PropertyDependencies"}) = (;urns = Vector{String}())
PB.field_numbers(::Type{var"ConstructRequest.PropertyDependencies"}) = (;urns = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ConstructRequest.PropertyDependencies"})
    urns = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, urns)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ConstructRequest.PropertyDependencies"(urns[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ConstructRequest.PropertyDependencies")
    initpos = position(e.io)
    !isempty(x.urns) && PB.encode(e, 1, x.urns)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ConstructRequest.PropertyDependencies")
    encoded_size = 0
    !isempty(x.urns) && (encoded_size += PB._encoded_size(x.urns, 1))
    return encoded_size
end

struct ConfigureRequest
    variables::Dict{String,String}
    args::Union{Nothing,google.protobuf.Struct}
    acceptSecrets::Bool
    acceptResources::Bool
    sends_old_inputs::Bool
    sends_old_inputs_to_delete::Bool
    id::String
    urn::String
    name::String
    var"#type"::String
end
PB.default_values(::Type{ConfigureRequest}) = (;variables = Dict{String,String}(), args = nothing, acceptSecrets = false, acceptResources = false, sends_old_inputs = false, sends_old_inputs_to_delete = false, id = "", urn = "", name = "", var"#type" = "")
PB.field_numbers(::Type{ConfigureRequest}) = (;variables = 1, args = 2, acceptSecrets = 3, acceptResources = 4, sends_old_inputs = 5, sends_old_inputs_to_delete = 6, id = 7, urn = 8, name = 9, var"#type" = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConfigureRequest})
    variables = Dict{String,String}()
    args = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    acceptSecrets = false
    acceptResources = false
    sends_old_inputs = false
    sends_old_inputs_to_delete = false
    id = ""
    urn = ""
    name = ""
    var"#type" = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, variables)
        elseif field_number == 2
            PB.decode!(d, args)
        elseif field_number == 3
            acceptSecrets = PB.decode(d, Bool)
        elseif field_number == 4
            acceptResources = PB.decode(d, Bool)
        elseif field_number == 5
            sends_old_inputs = PB.decode(d, Bool)
        elseif field_number == 6
            sends_old_inputs_to_delete = PB.decode(d, Bool)
        elseif field_number == 7
            id = PB.decode(d, String)
        elseif field_number == 8
            urn = PB.decode(d, String)
        elseif field_number == 9
            name = PB.decode(d, String)
        elseif field_number == 10
            var"#type" = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return ConfigureRequest(variables, args[], acceptSecrets, acceptResources, sends_old_inputs, sends_old_inputs_to_delete, id, urn, name, var"#type")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConfigureRequest)
    initpos = position(e.io)
    !isempty(x.variables) && PB.encode(e, 1, x.variables)
    !isnothing(x.args) && PB.encode(e, 2, x.args)
    x.acceptSecrets != false && PB.encode(e, 3, x.acceptSecrets)
    x.acceptResources != false && PB.encode(e, 4, x.acceptResources)
    x.sends_old_inputs != false && PB.encode(e, 5, x.sends_old_inputs)
    x.sends_old_inputs_to_delete != false && PB.encode(e, 6, x.sends_old_inputs_to_delete)
    !isempty(x.id) && PB.encode(e, 7, x.id)
    !isempty(x.urn) && PB.encode(e, 8, x.urn)
    !isempty(x.name) && PB.encode(e, 9, x.name)
    !isempty(x.var"#type") && PB.encode(e, 10, x.var"#type")
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConfigureRequest)
    encoded_size = 0
    !isempty(x.variables) && (encoded_size += PB._encoded_size(x.variables, 1))
    !isnothing(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    x.acceptSecrets != false && (encoded_size += PB._encoded_size(x.acceptSecrets, 3))
    x.acceptResources != false && (encoded_size += PB._encoded_size(x.acceptResources, 4))
    x.sends_old_inputs != false && (encoded_size += PB._encoded_size(x.sends_old_inputs, 5))
    x.sends_old_inputs_to_delete != false && (encoded_size += PB._encoded_size(x.sends_old_inputs_to_delete, 6))
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 7))
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 8))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 9))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 10))
    return encoded_size
end

struct var"CallRequest.ArgumentDependencies"
    urns::Vector{String}
end
PB.default_values(::Type{var"CallRequest.ArgumentDependencies"}) = (;urns = Vector{String}())
PB.field_numbers(::Type{var"CallRequest.ArgumentDependencies"}) = (;urns = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallRequest.ArgumentDependencies"})
    urns = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, urns)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"CallRequest.ArgumentDependencies"(urns[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallRequest.ArgumentDependencies")
    initpos = position(e.io)
    !isempty(x.urns) && PB.encode(e, 1, x.urns)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallRequest.ArgumentDependencies")
    encoded_size = 0
    !isempty(x.urns) && (encoded_size += PB._encoded_size(x.urns, 1))
    return encoded_size
end

struct GetMappingsResponse
    providers::Vector{String}
end
PB.default_values(::Type{GetMappingsResponse}) = (;providers = Vector{String}())
PB.field_numbers(::Type{GetMappingsResponse}) = (;providers = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetMappingsResponse})
    providers = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, providers)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetMappingsResponse(providers[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetMappingsResponse)
    initpos = position(e.io)
    !isempty(x.providers) && PB.encode(e, 1, x.providers)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetMappingsResponse)
    encoded_size = 0
    !isempty(x.providers) && (encoded_size += PB._encoded_size(x.providers, 1))
    return encoded_size
end

struct CreateRequest
    urn::String
    properties::Union{Nothing,google.protobuf.Struct}
    timeout::Float64
    preview::Bool
    name::String
    var"#type"::String
    resource_status_address::String
    resource_status_token::String
end
PB.default_values(::Type{CreateRequest}) = (;urn = "", properties = nothing, timeout = zero(Float64), preview = false, name = "", var"#type" = "", resource_status_address = "", resource_status_token = "")
PB.field_numbers(::Type{CreateRequest}) = (;urn = 1, properties = 2, timeout = 3, preview = 4, name = 5, var"#type" = 6, resource_status_address = 7, resource_status_token = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CreateRequest})
    urn = ""
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    timeout = zero(Float64)
    preview = false
    name = ""
    var"#type" = ""
    resource_status_address = ""
    resource_status_token = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            urn = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, properties)
        elseif field_number == 3
            timeout = PB.decode(d, Float64)
        elseif field_number == 4
            preview = PB.decode(d, Bool)
        elseif field_number == 5
            name = PB.decode(d, String)
        elseif field_number == 6
            var"#type" = PB.decode(d, String)
        elseif field_number == 7
            resource_status_address = PB.decode(d, String)
        elseif field_number == 8
            resource_status_token = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return CreateRequest(urn, properties[], timeout, preview, name, var"#type", resource_status_address, resource_status_token)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CreateRequest)
    initpos = position(e.io)
    !isempty(x.urn) && PB.encode(e, 1, x.urn)
    !isnothing(x.properties) && PB.encode(e, 2, x.properties)
    x.timeout !== zero(Float64) && PB.encode(e, 3, x.timeout)
    x.preview != false && PB.encode(e, 4, x.preview)
    !isempty(x.name) && PB.encode(e, 5, x.name)
    !isempty(x.var"#type") && PB.encode(e, 6, x.var"#type")
    !isempty(x.resource_status_address) && PB.encode(e, 7, x.resource_status_address)
    !isempty(x.resource_status_token) && PB.encode(e, 8, x.resource_status_token)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CreateRequest)
    encoded_size = 0
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 1))
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 2))
    x.timeout !== zero(Float64) && (encoded_size += PB._encoded_size(x.timeout, 3))
    x.preview != false && (encoded_size += PB._encoded_size(x.preview, 4))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 5))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 6))
    !isempty(x.resource_status_address) && (encoded_size += PB._encoded_size(x.resource_status_address, 7))
    !isempty(x.resource_status_token) && (encoded_size += PB._encoded_size(x.resource_status_token, 8))
    return encoded_size
end

struct var"CallResponse.ReturnDependencies"
    urns::Vector{String}
end
PB.default_values(::Type{var"CallResponse.ReturnDependencies"}) = (;urns = Vector{String}())
PB.field_numbers(::Type{var"CallResponse.ReturnDependencies"}) = (;urns = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallResponse.ReturnDependencies"})
    urns = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, urns)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"CallResponse.ReturnDependencies"(urns[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallResponse.ReturnDependencies")
    initpos = position(e.io)
    !isempty(x.urns) && PB.encode(e, 1, x.urns)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallResponse.ReturnDependencies")
    encoded_size = 0
    !isempty(x.urns) && (encoded_size += PB._encoded_size(x.urns, 1))
    return encoded_size
end

struct var"ParameterizeRequest.ParametersValue"
    name::String
    version::String
    value::Vector{UInt8}
end
PB.default_values(::Type{var"ParameterizeRequest.ParametersValue"}) = (;name = "", version = "", value = UInt8[])
PB.field_numbers(::Type{var"ParameterizeRequest.ParametersValue"}) = (;name = 1, version = 2, value = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ParameterizeRequest.ParametersValue"})
    name = ""
    version = ""
    value = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        elseif field_number == 3
            value = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ParameterizeRequest.ParametersValue"(name, version, value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ParameterizeRequest.ParametersValue")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    !isempty(x.value) && PB.encode(e, 3, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ParameterizeRequest.ParametersValue")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    !isempty(x.value) && (encoded_size += PB._encoded_size(x.value, 3))
    return encoded_size
end

struct ParameterizeResponse
    name::String
    version::String
end
PB.default_values(::Type{ParameterizeResponse}) = (;name = "", version = "")
PB.field_numbers(::Type{ParameterizeResponse}) = (;name = 1, version = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ParameterizeResponse})
    name = ""
    version = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return ParameterizeResponse(name, version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ParameterizeResponse)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ParameterizeResponse)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    return encoded_size
end

struct ConfigureResponse
    acceptSecrets::Bool
    supportsPreview::Bool
    acceptResources::Bool
    acceptOutputs::Bool
    supports_autonaming_configuration::Bool
end
PB.default_values(::Type{ConfigureResponse}) = (;acceptSecrets = false, supportsPreview = false, acceptResources = false, acceptOutputs = false, supports_autonaming_configuration = false)
PB.field_numbers(::Type{ConfigureResponse}) = (;acceptSecrets = 1, supportsPreview = 2, acceptResources = 3, acceptOutputs = 4, supports_autonaming_configuration = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConfigureResponse})
    acceptSecrets = false
    supportsPreview = false
    acceptResources = false
    acceptOutputs = false
    supports_autonaming_configuration = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            acceptSecrets = PB.decode(d, Bool)
        elseif field_number == 2
            supportsPreview = PB.decode(d, Bool)
        elseif field_number == 3
            acceptResources = PB.decode(d, Bool)
        elseif field_number == 4
            acceptOutputs = PB.decode(d, Bool)
        elseif field_number == 5
            supports_autonaming_configuration = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return ConfigureResponse(acceptSecrets, supportsPreview, acceptResources, acceptOutputs, supports_autonaming_configuration)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConfigureResponse)
    initpos = position(e.io)
    x.acceptSecrets != false && PB.encode(e, 1, x.acceptSecrets)
    x.supportsPreview != false && PB.encode(e, 2, x.supportsPreview)
    x.acceptResources != false && PB.encode(e, 3, x.acceptResources)
    x.acceptOutputs != false && PB.encode(e, 4, x.acceptOutputs)
    x.supports_autonaming_configuration != false && PB.encode(e, 5, x.supports_autonaming_configuration)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConfigureResponse)
    encoded_size = 0
    x.acceptSecrets != false && (encoded_size += PB._encoded_size(x.acceptSecrets, 1))
    x.supportsPreview != false && (encoded_size += PB._encoded_size(x.supportsPreview, 2))
    x.acceptResources != false && (encoded_size += PB._encoded_size(x.acceptResources, 3))
    x.acceptOutputs != false && (encoded_size += PB._encoded_size(x.acceptOutputs, 4))
    x.supports_autonaming_configuration != false && (encoded_size += PB._encoded_size(x.supports_autonaming_configuration, 5))
    return encoded_size
end

struct var"ConfigureErrorMissingKeys.MissingKey"
    name::String
    description::String
end
PB.default_values(::Type{var"ConfigureErrorMissingKeys.MissingKey"}) = (;name = "", description = "")
PB.field_numbers(::Type{var"ConfigureErrorMissingKeys.MissingKey"}) = (;name = 1, description = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ConfigureErrorMissingKeys.MissingKey"})
    name = ""
    description = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            description = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ConfigureErrorMissingKeys.MissingKey"(name, description)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ConfigureErrorMissingKeys.MissingKey")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.description) && PB.encode(e, 2, x.description)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ConfigureErrorMissingKeys.MissingKey")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 2))
    return encoded_size
end

struct GetSchemaRequest
    version::Int32
    subpackage_name::String
    subpackage_version::String
end
PB.default_values(::Type{GetSchemaRequest}) = (;version = zero(Int32), subpackage_name = "", subpackage_version = "")
PB.field_numbers(::Type{GetSchemaRequest}) = (;version = 1, subpackage_name = 2, subpackage_version = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetSchemaRequest})
    version = zero(Int32)
    subpackage_name = ""
    subpackage_version = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            version = PB.decode(d, Int32)
        elseif field_number == 2
            subpackage_name = PB.decode(d, String)
        elseif field_number == 3
            subpackage_version = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetSchemaRequest(version, subpackage_name, subpackage_version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetSchemaRequest)
    initpos = position(e.io)
    x.version != zero(Int32) && PB.encode(e, 1, x.version)
    !isempty(x.subpackage_name) && PB.encode(e, 2, x.subpackage_name)
    !isempty(x.subpackage_version) && PB.encode(e, 3, x.subpackage_version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetSchemaRequest)
    encoded_size = 0
    x.version != zero(Int32) && (encoded_size += PB._encoded_size(x.version, 1))
    !isempty(x.subpackage_name) && (encoded_size += PB._encoded_size(x.subpackage_name, 2))
    !isempty(x.subpackage_version) && (encoded_size += PB._encoded_size(x.subpackage_version, 3))
    return encoded_size
end

@enumx var"DiffResponse.DiffChanges" DIFF_UNKNOWN=0 DIFF_NONE=1 DIFF_SOME=2

struct CreateResponse
    id::String
    properties::Union{Nothing,google.protobuf.Struct}
    refresh_before_update::Bool
end
PB.default_values(::Type{CreateResponse}) = (;id = "", properties = nothing, refresh_before_update = false)
PB.field_numbers(::Type{CreateResponse}) = (;id = 1, properties = 2, refresh_before_update = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CreateResponse})
    id = ""
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    refresh_before_update = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, properties)
        elseif field_number == 3
            refresh_before_update = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return CreateResponse(id, properties[], refresh_before_update)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CreateResponse)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isnothing(x.properties) && PB.encode(e, 2, x.properties)
    x.refresh_before_update != false && PB.encode(e, 3, x.refresh_before_update)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CreateResponse)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 2))
    x.refresh_before_update != false && (encoded_size += PB._encoded_size(x.refresh_before_update, 3))
    return encoded_size
end

struct InvokeRequest
    tok::String
    args::Union{Nothing,google.protobuf.Struct}
    preview::Bool
end
PB.reserved_fields(::Type{InvokeRequest}) = (names = ["provider", "version", "acceptResources", "pluginDownloadURL"], numbers = Union{Int,UnitRange{Int}}[3:6])
PB.default_values(::Type{InvokeRequest}) = (;tok = "", args = nothing, preview = false)
PB.field_numbers(::Type{InvokeRequest}) = (;tok = 1, args = 2, preview = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InvokeRequest})
    tok = ""
    args = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    preview = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tok = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, args)
        elseif field_number == 7
            preview = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return InvokeRequest(tok, args[], preview)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InvokeRequest)
    initpos = position(e.io)
    !isempty(x.tok) && PB.encode(e, 1, x.tok)
    !isnothing(x.args) && PB.encode(e, 2, x.args)
    x.preview != false && PB.encode(e, 7, x.preview)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InvokeRequest)
    encoded_size = 0
    !isempty(x.tok) && (encoded_size += PB._encoded_size(x.tok, 1))
    !isnothing(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    x.preview != false && (encoded_size += PB._encoded_size(x.preview, 7))
    return encoded_size
end

struct ProviderHandshakeResponse
    accept_secrets::Bool
    accept_resources::Bool
    accept_outputs::Bool
    supports_autonaming_configuration::Bool
    pulumi_version_range::String
end
PB.default_values(::Type{ProviderHandshakeResponse}) = (;accept_secrets = false, accept_resources = false, accept_outputs = false, supports_autonaming_configuration = false, pulumi_version_range = "")
PB.field_numbers(::Type{ProviderHandshakeResponse}) = (;accept_secrets = 1, accept_resources = 2, accept_outputs = 3, supports_autonaming_configuration = 4, pulumi_version_range = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ProviderHandshakeResponse})
    accept_secrets = false
    accept_resources = false
    accept_outputs = false
    supports_autonaming_configuration = false
    pulumi_version_range = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            accept_secrets = PB.decode(d, Bool)
        elseif field_number == 2
            accept_resources = PB.decode(d, Bool)
        elseif field_number == 3
            accept_outputs = PB.decode(d, Bool)
        elseif field_number == 4
            supports_autonaming_configuration = PB.decode(d, Bool)
        elseif field_number == 5
            pulumi_version_range = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return ProviderHandshakeResponse(accept_secrets, accept_resources, accept_outputs, supports_autonaming_configuration, pulumi_version_range)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ProviderHandshakeResponse)
    initpos = position(e.io)
    x.accept_secrets != false && PB.encode(e, 1, x.accept_secrets)
    x.accept_resources != false && PB.encode(e, 2, x.accept_resources)
    x.accept_outputs != false && PB.encode(e, 3, x.accept_outputs)
    x.supports_autonaming_configuration != false && PB.encode(e, 4, x.supports_autonaming_configuration)
    !isempty(x.pulumi_version_range) && PB.encode(e, 5, x.pulumi_version_range)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ProviderHandshakeResponse)
    encoded_size = 0
    x.accept_secrets != false && (encoded_size += PB._encoded_size(x.accept_secrets, 1))
    x.accept_resources != false && (encoded_size += PB._encoded_size(x.accept_resources, 2))
    x.accept_outputs != false && (encoded_size += PB._encoded_size(x.accept_outputs, 3))
    x.supports_autonaming_configuration != false && (encoded_size += PB._encoded_size(x.supports_autonaming_configuration, 4))
    !isempty(x.pulumi_version_range) && (encoded_size += PB._encoded_size(x.pulumi_version_range, 5))
    return encoded_size
end

struct View
    var"#type"::String
    name::String
    parent_type::String
    parent_name::String
    inputs::Union{Nothing,google.protobuf.Struct}
    outputs::Union{Nothing,google.protobuf.Struct}
end
PB.default_values(::Type{View}) = (;var"#type" = "", name = "", parent_type = "", parent_name = "", inputs = nothing, outputs = nothing)
PB.field_numbers(::Type{View}) = (;var"#type" = 1, name = 2, parent_type = 3, parent_name = 4, inputs = 5, outputs = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:View})
    var"#type" = ""
    name = ""
    parent_type = ""
    parent_name = ""
    inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    outputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#type" = PB.decode(d, String)
        elseif field_number == 2
            name = PB.decode(d, String)
        elseif field_number == 3
            parent_type = PB.decode(d, String)
        elseif field_number == 4
            parent_name = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, inputs)
        elseif field_number == 6
            PB.decode!(d, outputs)
        else
            Base.skip(d, wire_type)
        end
    end
    return View(var"#type", name, parent_type, parent_name, inputs[], outputs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::View)
    initpos = position(e.io)
    !isempty(x.var"#type") && PB.encode(e, 1, x.var"#type")
    !isempty(x.name) && PB.encode(e, 2, x.name)
    !isempty(x.parent_type) && PB.encode(e, 3, x.parent_type)
    !isempty(x.parent_name) && PB.encode(e, 4, x.parent_name)
    !isnothing(x.inputs) && PB.encode(e, 5, x.inputs)
    !isnothing(x.outputs) && PB.encode(e, 6, x.outputs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::View)
    encoded_size = 0
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 1))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 2))
    !isempty(x.parent_type) && (encoded_size += PB._encoded_size(x.parent_type, 3))
    !isempty(x.parent_name) && (encoded_size += PB._encoded_size(x.parent_name, 4))
    !isnothing(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 5))
    !isnothing(x.outputs) && (encoded_size += PB._encoded_size(x.outputs, 6))
    return encoded_size
end

@enumx var"PropertyDiff.Kind" ADD=0 ADD_REPLACE=1 DELETE=2 DELETE_REPLACE=3 UPDATE=4 UPDATE_REPLACE=5

struct var"ConstructRequest.CustomTimeouts"
    create::String
    update::String
    delete::String
end
PB.default_values(::Type{var"ConstructRequest.CustomTimeouts"}) = (;create = "", update = "", delete = "")
PB.field_numbers(::Type{var"ConstructRequest.CustomTimeouts"}) = (;create = 1, update = 2, delete = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ConstructRequest.CustomTimeouts"})
    create = ""
    update = ""
    delete = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            create = PB.decode(d, String)
        elseif field_number == 2
            update = PB.decode(d, String)
        elseif field_number == 3
            delete = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ConstructRequest.CustomTimeouts"(create, update, delete)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ConstructRequest.CustomTimeouts")
    initpos = position(e.io)
    !isempty(x.create) && PB.encode(e, 1, x.create)
    !isempty(x.update) && PB.encode(e, 2, x.update)
    !isempty(x.delete) && PB.encode(e, 3, x.delete)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ConstructRequest.CustomTimeouts")
    encoded_size = 0
    !isempty(x.create) && (encoded_size += PB._encoded_size(x.create, 1))
    !isempty(x.update) && (encoded_size += PB._encoded_size(x.update, 2))
    !isempty(x.delete) && (encoded_size += PB._encoded_size(x.delete, 3))
    return encoded_size
end

struct UpdateResponse
    properties::Union{Nothing,google.protobuf.Struct}
    refresh_before_update::Bool
end
PB.default_values(::Type{UpdateResponse}) = (;properties = nothing, refresh_before_update = false)
PB.field_numbers(::Type{UpdateResponse}) = (;properties = 1, refresh_before_update = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UpdateResponse})
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    refresh_before_update = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, properties)
        elseif field_number == 2
            refresh_before_update = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return UpdateResponse(properties[], refresh_before_update)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UpdateResponse)
    initpos = position(e.io)
    !isnothing(x.properties) && PB.encode(e, 1, x.properties)
    x.refresh_before_update != false && PB.encode(e, 2, x.refresh_before_update)
    return position(e.io) - initpos
end
function PB._encoded_size(x::UpdateResponse)
    encoded_size = 0
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 1))
    x.refresh_before_update != false && (encoded_size += PB._encoded_size(x.refresh_before_update, 2))
    return encoded_size
end

@enumx var"CheckRequest.AutonamingOptions.Mode" PROPOSE=0 ENFORCE=1 DISABLE=2

struct GetSchemaResponse
    schema::String
end
PB.default_values(::Type{GetSchemaResponse}) = (;schema = "")
PB.field_numbers(::Type{GetSchemaResponse}) = (;schema = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetSchemaResponse})
    schema = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            schema = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetSchemaResponse(schema)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetSchemaResponse)
    initpos = position(e.io)
    !isempty(x.schema) && PB.encode(e, 1, x.schema)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetSchemaResponse)
    encoded_size = 0
    !isempty(x.schema) && (encoded_size += PB._encoded_size(x.schema, 1))
    return encoded_size
end

struct var"ConstructResponse.PropertyDependencies"
    urns::Vector{String}
end
PB.default_values(::Type{var"ConstructResponse.PropertyDependencies"}) = (;urns = Vector{String}())
PB.field_numbers(::Type{var"ConstructResponse.PropertyDependencies"}) = (;urns = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ConstructResponse.PropertyDependencies"})
    urns = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, urns)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ConstructResponse.PropertyDependencies"(urns[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ConstructResponse.PropertyDependencies")
    initpos = position(e.io)
    !isempty(x.urns) && PB.encode(e, 1, x.urns)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ConstructResponse.PropertyDependencies")
    encoded_size = 0
    !isempty(x.urns) && (encoded_size += PB._encoded_size(x.urns, 1))
    return encoded_size
end

struct ErrorResourceInitFailed
    id::String
    properties::Union{Nothing,google.protobuf.Struct}
    reasons::Vector{String}
    inputs::Union{Nothing,google.protobuf.Struct}
    refresh_before_update::Bool
end
PB.default_values(::Type{ErrorResourceInitFailed}) = (;id = "", properties = nothing, reasons = Vector{String}(), inputs = nothing, refresh_before_update = false)
PB.field_numbers(::Type{ErrorResourceInitFailed}) = (;id = 1, properties = 2, reasons = 3, inputs = 4, refresh_before_update = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ErrorResourceInitFailed})
    id = ""
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    reasons = PB.BufferedVector{String}()
    inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    refresh_before_update = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, properties)
        elseif field_number == 3
            PB.decode!(d, reasons)
        elseif field_number == 4
            PB.decode!(d, inputs)
        elseif field_number == 5
            refresh_before_update = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return ErrorResourceInitFailed(id, properties[], reasons[], inputs[], refresh_before_update)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ErrorResourceInitFailed)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isnothing(x.properties) && PB.encode(e, 2, x.properties)
    !isempty(x.reasons) && PB.encode(e, 3, x.reasons)
    !isnothing(x.inputs) && PB.encode(e, 4, x.inputs)
    x.refresh_before_update != false && PB.encode(e, 5, x.refresh_before_update)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ErrorResourceInitFailed)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 2))
    !isempty(x.reasons) && (encoded_size += PB._encoded_size(x.reasons, 3))
    !isnothing(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 4))
    x.refresh_before_update != false && (encoded_size += PB._encoded_size(x.refresh_before_update, 5))
    return encoded_size
end

struct ReadResponse
    id::String
    properties::Union{Nothing,google.protobuf.Struct}
    inputs::Union{Nothing,google.protobuf.Struct}
    refresh_before_update::Bool
end
PB.default_values(::Type{ReadResponse}) = (;id = "", properties = nothing, inputs = nothing, refresh_before_update = false)
PB.field_numbers(::Type{ReadResponse}) = (;id = 1, properties = 2, inputs = 3, refresh_before_update = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ReadResponse})
    id = ""
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    refresh_before_update = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, properties)
        elseif field_number == 3
            PB.decode!(d, inputs)
        elseif field_number == 4
            refresh_before_update = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return ReadResponse(id, properties[], inputs[], refresh_before_update)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ReadResponse)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isnothing(x.properties) && PB.encode(e, 2, x.properties)
    !isnothing(x.inputs) && PB.encode(e, 3, x.inputs)
    x.refresh_before_update != false && PB.encode(e, 4, x.refresh_before_update)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ReadResponse)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 2))
    !isnothing(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 3))
    x.refresh_before_update != false && (encoded_size += PB._encoded_size(x.refresh_before_update, 4))
    return encoded_size
end

struct GetMappingsRequest
    key::String
end
PB.default_values(::Type{GetMappingsRequest}) = (;key = "")
PB.field_numbers(::Type{GetMappingsRequest}) = (;key = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetMappingsRequest})
    key = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetMappingsRequest(key)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetMappingsRequest)
    initpos = position(e.io)
    !isempty(x.key) && PB.encode(e, 1, x.key)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetMappingsRequest)
    encoded_size = 0
    !isempty(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    return encoded_size
end

struct var"ConstructRequest.ResourceHooksBinding"
    before_create::Vector{String}
    after_create::Vector{String}
    before_update::Vector{String}
    after_update::Vector{String}
    before_delete::Vector{String}
    after_delete::Vector{String}
end
PB.default_values(::Type{var"ConstructRequest.ResourceHooksBinding"}) = (;before_create = Vector{String}(), after_create = Vector{String}(), before_update = Vector{String}(), after_update = Vector{String}(), before_delete = Vector{String}(), after_delete = Vector{String}())
PB.field_numbers(::Type{var"ConstructRequest.ResourceHooksBinding"}) = (;before_create = 1, after_create = 2, before_update = 3, after_update = 4, before_delete = 5, after_delete = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"ConstructRequest.ResourceHooksBinding"})
    before_create = PB.BufferedVector{String}()
    after_create = PB.BufferedVector{String}()
    before_update = PB.BufferedVector{String}()
    after_update = PB.BufferedVector{String}()
    before_delete = PB.BufferedVector{String}()
    after_delete = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, before_create)
        elseif field_number == 2
            PB.decode!(d, after_create)
        elseif field_number == 3
            PB.decode!(d, before_update)
        elseif field_number == 4
            PB.decode!(d, after_update)
        elseif field_number == 5
            PB.decode!(d, before_delete)
        elseif field_number == 6
            PB.decode!(d, after_delete)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"ConstructRequest.ResourceHooksBinding"(before_create[], after_create[], before_update[], after_update[], before_delete[], after_delete[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"ConstructRequest.ResourceHooksBinding")
    initpos = position(e.io)
    !isempty(x.before_create) && PB.encode(e, 1, x.before_create)
    !isempty(x.after_create) && PB.encode(e, 2, x.after_create)
    !isempty(x.before_update) && PB.encode(e, 3, x.before_update)
    !isempty(x.after_update) && PB.encode(e, 4, x.after_update)
    !isempty(x.before_delete) && PB.encode(e, 5, x.before_delete)
    !isempty(x.after_delete) && PB.encode(e, 6, x.after_delete)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"ConstructRequest.ResourceHooksBinding")
    encoded_size = 0
    !isempty(x.before_create) && (encoded_size += PB._encoded_size(x.before_create, 1))
    !isempty(x.after_create) && (encoded_size += PB._encoded_size(x.after_create, 2))
    !isempty(x.before_update) && (encoded_size += PB._encoded_size(x.before_update, 3))
    !isempty(x.after_update) && (encoded_size += PB._encoded_size(x.after_update, 4))
    !isempty(x.before_delete) && (encoded_size += PB._encoded_size(x.before_delete, 5))
    !isempty(x.after_delete) && (encoded_size += PB._encoded_size(x.after_delete, 6))
    return encoded_size
end

struct InvokeResponse
    var"#return"::Union{Nothing,google.protobuf.Struct}
    failures::Vector{CheckFailure}
end
PB.default_values(::Type{InvokeResponse}) = (;var"#return" = nothing, failures = Vector{CheckFailure}())
PB.field_numbers(::Type{InvokeResponse}) = (;var"#return" = 1, failures = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InvokeResponse})
    var"#return" = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    failures = PB.BufferedVector{CheckFailure}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#return")
        elseif field_number == 2
            PB.decode!(d, failures)
        else
            Base.skip(d, wire_type)
        end
    end
    return InvokeResponse(var"#return"[], failures[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InvokeResponse)
    initpos = position(e.io)
    !isnothing(x.var"#return") && PB.encode(e, 1, x.var"#return")
    !isempty(x.failures) && PB.encode(e, 2, x.failures)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InvokeResponse)
    encoded_size = 0
    !isnothing(x.var"#return") && (encoded_size += PB._encoded_size(x.var"#return", 1))
    !isempty(x.failures) && (encoded_size += PB._encoded_size(x.failures, 2))
    return encoded_size
end

struct CheckResponse
    inputs::Union{Nothing,google.protobuf.Struct}
    failures::Vector{CheckFailure}
end
PB.default_values(::Type{CheckResponse}) = (;inputs = nothing, failures = Vector{CheckFailure}())
PB.field_numbers(::Type{CheckResponse}) = (;inputs = 1, failures = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CheckResponse})
    inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    failures = PB.BufferedVector{CheckFailure}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, inputs)
        elseif field_number == 2
            PB.decode!(d, failures)
        else
            Base.skip(d, wire_type)
        end
    end
    return CheckResponse(inputs[], failures[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CheckResponse)
    initpos = position(e.io)
    !isnothing(x.inputs) && PB.encode(e, 1, x.inputs)
    !isempty(x.failures) && PB.encode(e, 2, x.failures)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CheckResponse)
    encoded_size = 0
    !isnothing(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 1))
    !isempty(x.failures) && (encoded_size += PB._encoded_size(x.failures, 2))
    return encoded_size
end

struct CallRequest
    tok::String
    args::Union{Nothing,google.protobuf.Struct}
    argDependencies::Dict{String,var"CallRequest.ArgumentDependencies"}
    project::String
    stack::String
    config::Dict{String,String}
    configSecretKeys::Vector{String}
    dryRun::Bool
    parallel::Int32
    monitorEndpoint::String
    organization::String
    accepts_output_values::Bool
    stack_trace_handle::String
end
PB.reserved_fields(::Type{CallRequest}) = (names = ["provider", "version", "pluginDownloadURL", "pluginChecksums", "sourcePosition"], numbers = Union{Int,UnitRange{Int}}[4, 5, 13, 16, 15])
PB.default_values(::Type{CallRequest}) = (;tok = "", args = nothing, argDependencies = Dict{String,var"CallRequest.ArgumentDependencies"}(), project = "", stack = "", config = Dict{String,String}(), configSecretKeys = Vector{String}(), dryRun = false, parallel = zero(Int32), monitorEndpoint = "", organization = "", accepts_output_values = false, stack_trace_handle = "")
PB.field_numbers(::Type{CallRequest}) = (;tok = 1, args = 2, argDependencies = 3, project = 6, stack = 7, config = 8, configSecretKeys = 9, dryRun = 10, parallel = 11, monitorEndpoint = 12, organization = 14, accepts_output_values = 17, stack_trace_handle = 18)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CallRequest})
    tok = ""
    args = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    argDependencies = Dict{String,var"CallRequest.ArgumentDependencies"}()
    project = ""
    stack = ""
    config = Dict{String,String}()
    configSecretKeys = PB.BufferedVector{String}()
    dryRun = false
    parallel = zero(Int32)
    monitorEndpoint = ""
    organization = ""
    accepts_output_values = false
    stack_trace_handle = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            tok = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, args)
        elseif field_number == 3
            PB.decode!(d, argDependencies)
        elseif field_number == 6
            project = PB.decode(d, String)
        elseif field_number == 7
            stack = PB.decode(d, String)
        elseif field_number == 8
            PB.decode!(d, config)
        elseif field_number == 9
            PB.decode!(d, configSecretKeys)
        elseif field_number == 10
            dryRun = PB.decode(d, Bool)
        elseif field_number == 11
            parallel = PB.decode(d, Int32)
        elseif field_number == 12
            monitorEndpoint = PB.decode(d, String)
        elseif field_number == 14
            organization = PB.decode(d, String)
        elseif field_number == 17
            accepts_output_values = PB.decode(d, Bool)
        elseif field_number == 18
            stack_trace_handle = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return CallRequest(tok, args[], argDependencies, project, stack, config, configSecretKeys[], dryRun, parallel, monitorEndpoint, organization, accepts_output_values, stack_trace_handle)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CallRequest)
    initpos = position(e.io)
    !isempty(x.tok) && PB.encode(e, 1, x.tok)
    !isnothing(x.args) && PB.encode(e, 2, x.args)
    !isempty(x.argDependencies) && PB.encode(e, 3, x.argDependencies)
    !isempty(x.project) && PB.encode(e, 6, x.project)
    !isempty(x.stack) && PB.encode(e, 7, x.stack)
    !isempty(x.config) && PB.encode(e, 8, x.config)
    !isempty(x.configSecretKeys) && PB.encode(e, 9, x.configSecretKeys)
    x.dryRun != false && PB.encode(e, 10, x.dryRun)
    x.parallel != zero(Int32) && PB.encode(e, 11, x.parallel)
    !isempty(x.monitorEndpoint) && PB.encode(e, 12, x.monitorEndpoint)
    !isempty(x.organization) && PB.encode(e, 14, x.organization)
    x.accepts_output_values != false && PB.encode(e, 17, x.accepts_output_values)
    !isempty(x.stack_trace_handle) && PB.encode(e, 18, x.stack_trace_handle)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CallRequest)
    encoded_size = 0
    !isempty(x.tok) && (encoded_size += PB._encoded_size(x.tok, 1))
    !isnothing(x.args) && (encoded_size += PB._encoded_size(x.args, 2))
    !isempty(x.argDependencies) && (encoded_size += PB._encoded_size(x.argDependencies, 3))
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 6))
    !isempty(x.stack) && (encoded_size += PB._encoded_size(x.stack, 7))
    !isempty(x.config) && (encoded_size += PB._encoded_size(x.config, 8))
    !isempty(x.configSecretKeys) && (encoded_size += PB._encoded_size(x.configSecretKeys, 9))
    x.dryRun != false && (encoded_size += PB._encoded_size(x.dryRun, 10))
    x.parallel != zero(Int32) && (encoded_size += PB._encoded_size(x.parallel, 11))
    !isempty(x.monitorEndpoint) && (encoded_size += PB._encoded_size(x.monitorEndpoint, 12))
    !isempty(x.organization) && (encoded_size += PB._encoded_size(x.organization, 14))
    x.accepts_output_values != false && (encoded_size += PB._encoded_size(x.accepts_output_values, 17))
    !isempty(x.stack_trace_handle) && (encoded_size += PB._encoded_size(x.stack_trace_handle, 18))
    return encoded_size
end

struct CallResponse
    var"#return"::Union{Nothing,google.protobuf.Struct}
    failures::Vector{CheckFailure}
    returnDependencies::Dict{String,var"CallResponse.ReturnDependencies"}
end
PB.default_values(::Type{CallResponse}) = (;var"#return" = nothing, failures = Vector{CheckFailure}(), returnDependencies = Dict{String,var"CallResponse.ReturnDependencies"}())
PB.field_numbers(::Type{CallResponse}) = (;var"#return" = 1, failures = 3, returnDependencies = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CallResponse})
    var"#return" = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    failures = PB.BufferedVector{CheckFailure}()
    returnDependencies = Dict{String,var"CallResponse.ReturnDependencies"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, var"#return")
        elseif field_number == 3
            PB.decode!(d, failures)
        elseif field_number == 2
            PB.decode!(d, returnDependencies)
        else
            Base.skip(d, wire_type)
        end
    end
    return CallResponse(var"#return"[], failures[], returnDependencies)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CallResponse)
    initpos = position(e.io)
    !isnothing(x.var"#return") && PB.encode(e, 1, x.var"#return")
    !isempty(x.failures) && PB.encode(e, 3, x.failures)
    !isempty(x.returnDependencies) && PB.encode(e, 2, x.returnDependencies)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CallResponse)
    encoded_size = 0
    !isnothing(x.var"#return") && (encoded_size += PB._encoded_size(x.var"#return", 1))
    !isempty(x.failures) && (encoded_size += PB._encoded_size(x.failures, 3))
    !isempty(x.returnDependencies) && (encoded_size += PB._encoded_size(x.returnDependencies, 2))
    return encoded_size
end

struct ParameterizeRequest
    parameters::Union{Nothing,OneOf{<:Union{var"ParameterizeRequest.ParametersArgs",var"ParameterizeRequest.ParametersValue"}}}
end
PB.oneof_field_types(::Type{ParameterizeRequest}) = (;
    parameters = (;args=var"ParameterizeRequest.ParametersArgs", value=var"ParameterizeRequest.ParametersValue"),
)
PB.default_values(::Type{ParameterizeRequest}) = (;args = nothing, value = nothing)
PB.field_numbers(::Type{ParameterizeRequest}) = (;args = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ParameterizeRequest})
    parameters = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            parameters = OneOf(:args, PB.decode(d, Ref{var"ParameterizeRequest.ParametersArgs"}))
        elseif field_number == 2
            parameters = OneOf(:value, PB.decode(d, Ref{var"ParameterizeRequest.ParametersValue"}))
        else
            Base.skip(d, wire_type)
        end
    end
    return ParameterizeRequest(parameters)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ParameterizeRequest)
    initpos = position(e.io)
    if isnothing(x.parameters);
    elseif x.parameters.name === :args
        PB.encode(e, 1, x.parameters[]::var"ParameterizeRequest.ParametersArgs")
    elseif x.parameters.name === :value
        PB.encode(e, 2, x.parameters[]::var"ParameterizeRequest.ParametersValue")
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ParameterizeRequest)
    encoded_size = 0
    if isnothing(x.parameters);
    elseif x.parameters.name === :args
        encoded_size += PB._encoded_size(x.parameters[]::var"ParameterizeRequest.ParametersArgs", 1)
    elseif x.parameters.name === :value
        encoded_size += PB._encoded_size(x.parameters[]::var"ParameterizeRequest.ParametersValue", 2)
    end
    return encoded_size
end

struct ConfigureErrorMissingKeys
    missingKeys::Vector{var"ConfigureErrorMissingKeys.MissingKey"}
end
PB.default_values(::Type{ConfigureErrorMissingKeys}) = (;missingKeys = Vector{var"ConfigureErrorMissingKeys.MissingKey"}())
PB.field_numbers(::Type{ConfigureErrorMissingKeys}) = (;missingKeys = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConfigureErrorMissingKeys})
    missingKeys = PB.BufferedVector{var"ConfigureErrorMissingKeys.MissingKey"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, missingKeys)
        else
            Base.skip(d, wire_type)
        end
    end
    return ConfigureErrorMissingKeys(missingKeys[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConfigureErrorMissingKeys)
    initpos = position(e.io)
    !isempty(x.missingKeys) && PB.encode(e, 1, x.missingKeys)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConfigureErrorMissingKeys)
    encoded_size = 0
    !isempty(x.missingKeys) && (encoded_size += PB._encoded_size(x.missingKeys, 1))
    return encoded_size
end

struct UpdateRequest
    id::String
    urn::String
    olds::Union{Nothing,google.protobuf.Struct}
    news::Union{Nothing,google.protobuf.Struct}
    timeout::Float64
    ignoreChanges::Vector{String}
    preview::Bool
    old_inputs::Union{Nothing,google.protobuf.Struct}
    name::String
    var"#type"::String
    resource_status_address::String
    resource_status_token::String
    old_views::Vector{View}
end
PB.default_values(::Type{UpdateRequest}) = (;id = "", urn = "", olds = nothing, news = nothing, timeout = zero(Float64), ignoreChanges = Vector{String}(), preview = false, old_inputs = nothing, name = "", var"#type" = "", resource_status_address = "", resource_status_token = "", old_views = Vector{View}())
PB.field_numbers(::Type{UpdateRequest}) = (;id = 1, urn = 2, olds = 3, news = 4, timeout = 5, ignoreChanges = 6, preview = 7, old_inputs = 8, name = 9, var"#type" = 10, resource_status_address = 11, resource_status_token = 12, old_views = 13)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:UpdateRequest})
    id = ""
    urn = ""
    olds = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    news = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    timeout = zero(Float64)
    ignoreChanges = PB.BufferedVector{String}()
    preview = false
    old_inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    name = ""
    var"#type" = ""
    resource_status_address = ""
    resource_status_token = ""
    old_views = PB.BufferedVector{View}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            urn = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, olds)
        elseif field_number == 4
            PB.decode!(d, news)
        elseif field_number == 5
            timeout = PB.decode(d, Float64)
        elseif field_number == 6
            PB.decode!(d, ignoreChanges)
        elseif field_number == 7
            preview = PB.decode(d, Bool)
        elseif field_number == 8
            PB.decode!(d, old_inputs)
        elseif field_number == 9
            name = PB.decode(d, String)
        elseif field_number == 10
            var"#type" = PB.decode(d, String)
        elseif field_number == 11
            resource_status_address = PB.decode(d, String)
        elseif field_number == 12
            resource_status_token = PB.decode(d, String)
        elseif field_number == 13
            PB.decode!(d, old_views)
        else
            Base.skip(d, wire_type)
        end
    end
    return UpdateRequest(id, urn, olds[], news[], timeout, ignoreChanges[], preview, old_inputs[], name, var"#type", resource_status_address, resource_status_token, old_views[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::UpdateRequest)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isempty(x.urn) && PB.encode(e, 2, x.urn)
    !isnothing(x.olds) && PB.encode(e, 3, x.olds)
    !isnothing(x.news) && PB.encode(e, 4, x.news)
    x.timeout !== zero(Float64) && PB.encode(e, 5, x.timeout)
    !isempty(x.ignoreChanges) && PB.encode(e, 6, x.ignoreChanges)
    x.preview != false && PB.encode(e, 7, x.preview)
    !isnothing(x.old_inputs) && PB.encode(e, 8, x.old_inputs)
    !isempty(x.name) && PB.encode(e, 9, x.name)
    !isempty(x.var"#type") && PB.encode(e, 10, x.var"#type")
    !isempty(x.resource_status_address) && PB.encode(e, 11, x.resource_status_address)
    !isempty(x.resource_status_token) && PB.encode(e, 12, x.resource_status_token)
    !isempty(x.old_views) && PB.encode(e, 13, x.old_views)
    return position(e.io) - initpos
end
function PB._encoded_size(x::UpdateRequest)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 2))
    !isnothing(x.olds) && (encoded_size += PB._encoded_size(x.olds, 3))
    !isnothing(x.news) && (encoded_size += PB._encoded_size(x.news, 4))
    x.timeout !== zero(Float64) && (encoded_size += PB._encoded_size(x.timeout, 5))
    !isempty(x.ignoreChanges) && (encoded_size += PB._encoded_size(x.ignoreChanges, 6))
    x.preview != false && (encoded_size += PB._encoded_size(x.preview, 7))
    !isnothing(x.old_inputs) && (encoded_size += PB._encoded_size(x.old_inputs, 8))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 9))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 10))
    !isempty(x.resource_status_address) && (encoded_size += PB._encoded_size(x.resource_status_address, 11))
    !isempty(x.resource_status_token) && (encoded_size += PB._encoded_size(x.resource_status_token, 12))
    !isempty(x.old_views) && (encoded_size += PB._encoded_size(x.old_views, 13))
    return encoded_size
end

struct ReadRequest
    id::String
    urn::String
    properties::Union{Nothing,google.protobuf.Struct}
    inputs::Union{Nothing,google.protobuf.Struct}
    name::String
    var"#type"::String
    resource_status_address::String
    resource_status_token::String
    old_views::Vector{View}
end
PB.default_values(::Type{ReadRequest}) = (;id = "", urn = "", properties = nothing, inputs = nothing, name = "", var"#type" = "", resource_status_address = "", resource_status_token = "", old_views = Vector{View}())
PB.field_numbers(::Type{ReadRequest}) = (;id = 1, urn = 2, properties = 3, inputs = 4, name = 5, var"#type" = 6, resource_status_address = 7, resource_status_token = 8, old_views = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ReadRequest})
    id = ""
    urn = ""
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    name = ""
    var"#type" = ""
    resource_status_address = ""
    resource_status_token = ""
    old_views = PB.BufferedVector{View}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            urn = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, properties)
        elseif field_number == 4
            PB.decode!(d, inputs)
        elseif field_number == 5
            name = PB.decode(d, String)
        elseif field_number == 6
            var"#type" = PB.decode(d, String)
        elseif field_number == 7
            resource_status_address = PB.decode(d, String)
        elseif field_number == 8
            resource_status_token = PB.decode(d, String)
        elseif field_number == 9
            PB.decode!(d, old_views)
        else
            Base.skip(d, wire_type)
        end
    end
    return ReadRequest(id, urn, properties[], inputs[], name, var"#type", resource_status_address, resource_status_token, old_views[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ReadRequest)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isempty(x.urn) && PB.encode(e, 2, x.urn)
    !isnothing(x.properties) && PB.encode(e, 3, x.properties)
    !isnothing(x.inputs) && PB.encode(e, 4, x.inputs)
    !isempty(x.name) && PB.encode(e, 5, x.name)
    !isempty(x.var"#type") && PB.encode(e, 6, x.var"#type")
    !isempty(x.resource_status_address) && PB.encode(e, 7, x.resource_status_address)
    !isempty(x.resource_status_token) && PB.encode(e, 8, x.resource_status_token)
    !isempty(x.old_views) && PB.encode(e, 9, x.old_views)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ReadRequest)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 2))
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 3))
    !isnothing(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 4))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 5))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 6))
    !isempty(x.resource_status_address) && (encoded_size += PB._encoded_size(x.resource_status_address, 7))
    !isempty(x.resource_status_token) && (encoded_size += PB._encoded_size(x.resource_status_token, 8))
    !isempty(x.old_views) && (encoded_size += PB._encoded_size(x.old_views, 9))
    return encoded_size
end

struct DeleteRequest
    id::String
    urn::String
    properties::Union{Nothing,google.protobuf.Struct}
    timeout::Float64
    old_inputs::Union{Nothing,google.protobuf.Struct}
    name::String
    var"#type"::String
    resource_status_address::String
    resource_status_token::String
    old_views::Vector{View}
end
PB.default_values(::Type{DeleteRequest}) = (;id = "", urn = "", properties = nothing, timeout = zero(Float64), old_inputs = nothing, name = "", var"#type" = "", resource_status_address = "", resource_status_token = "", old_views = Vector{View}())
PB.field_numbers(::Type{DeleteRequest}) = (;id = 1, urn = 2, properties = 3, timeout = 4, old_inputs = 5, name = 6, var"#type" = 7, resource_status_address = 8, resource_status_token = 9, old_views = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DeleteRequest})
    id = ""
    urn = ""
    properties = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    timeout = zero(Float64)
    old_inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    name = ""
    var"#type" = ""
    resource_status_address = ""
    resource_status_token = ""
    old_views = PB.BufferedVector{View}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            id = PB.decode(d, String)
        elseif field_number == 2
            urn = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, properties)
        elseif field_number == 4
            timeout = PB.decode(d, Float64)
        elseif field_number == 5
            PB.decode!(d, old_inputs)
        elseif field_number == 6
            name = PB.decode(d, String)
        elseif field_number == 7
            var"#type" = PB.decode(d, String)
        elseif field_number == 8
            resource_status_address = PB.decode(d, String)
        elseif field_number == 9
            resource_status_token = PB.decode(d, String)
        elseif field_number == 10
            PB.decode!(d, old_views)
        else
            Base.skip(d, wire_type)
        end
    end
    return DeleteRequest(id, urn, properties[], timeout, old_inputs[], name, var"#type", resource_status_address, resource_status_token, old_views[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DeleteRequest)
    initpos = position(e.io)
    !isempty(x.id) && PB.encode(e, 1, x.id)
    !isempty(x.urn) && PB.encode(e, 2, x.urn)
    !isnothing(x.properties) && PB.encode(e, 3, x.properties)
    x.timeout !== zero(Float64) && PB.encode(e, 4, x.timeout)
    !isnothing(x.old_inputs) && PB.encode(e, 5, x.old_inputs)
    !isempty(x.name) && PB.encode(e, 6, x.name)
    !isempty(x.var"#type") && PB.encode(e, 7, x.var"#type")
    !isempty(x.resource_status_address) && PB.encode(e, 8, x.resource_status_address)
    !isempty(x.resource_status_token) && PB.encode(e, 9, x.resource_status_token)
    !isempty(x.old_views) && PB.encode(e, 10, x.old_views)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DeleteRequest)
    encoded_size = 0
    !isempty(x.id) && (encoded_size += PB._encoded_size(x.id, 1))
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 2))
    !isnothing(x.properties) && (encoded_size += PB._encoded_size(x.properties, 3))
    x.timeout !== zero(Float64) && (encoded_size += PB._encoded_size(x.timeout, 4))
    !isnothing(x.old_inputs) && (encoded_size += PB._encoded_size(x.old_inputs, 5))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 6))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 7))
    !isempty(x.resource_status_address) && (encoded_size += PB._encoded_size(x.resource_status_address, 8))
    !isempty(x.resource_status_token) && (encoded_size += PB._encoded_size(x.resource_status_token, 9))
    !isempty(x.old_views) && (encoded_size += PB._encoded_size(x.old_views, 10))
    return encoded_size
end

struct PropertyDiff
    kind::var"PropertyDiff.Kind".T
    inputDiff::Bool
end
PB.default_values(::Type{PropertyDiff}) = (;kind = var"PropertyDiff.Kind".ADD, inputDiff = false)
PB.field_numbers(::Type{PropertyDiff}) = (;kind = 1, inputDiff = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PropertyDiff})
    kind = var"PropertyDiff.Kind".ADD
    inputDiff = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            kind = PB.decode(d, var"PropertyDiff.Kind".T)
        elseif field_number == 2
            inputDiff = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return PropertyDiff(kind, inputDiff)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PropertyDiff)
    initpos = position(e.io)
    x.kind != var"PropertyDiff.Kind".ADD && PB.encode(e, 1, x.kind)
    x.inputDiff != false && PB.encode(e, 2, x.inputDiff)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PropertyDiff)
    encoded_size = 0
    x.kind != var"PropertyDiff.Kind".ADD && (encoded_size += PB._encoded_size(x.kind, 1))
    x.inputDiff != false && (encoded_size += PB._encoded_size(x.inputDiff, 2))
    return encoded_size
end

struct var"CheckRequest.AutonamingOptions"
    proposed_name::String
    mode::var"CheckRequest.AutonamingOptions.Mode".T
end
PB.default_values(::Type{var"CheckRequest.AutonamingOptions"}) = (;proposed_name = "", mode = var"CheckRequest.AutonamingOptions.Mode".PROPOSE)
PB.field_numbers(::Type{var"CheckRequest.AutonamingOptions"}) = (;proposed_name = 1, mode = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CheckRequest.AutonamingOptions"})
    proposed_name = ""
    mode = var"CheckRequest.AutonamingOptions.Mode".PROPOSE
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            proposed_name = PB.decode(d, String)
        elseif field_number == 2
            mode = PB.decode(d, var"CheckRequest.AutonamingOptions.Mode".T)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"CheckRequest.AutonamingOptions"(proposed_name, mode)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CheckRequest.AutonamingOptions")
    initpos = position(e.io)
    !isempty(x.proposed_name) && PB.encode(e, 1, x.proposed_name)
    x.mode != var"CheckRequest.AutonamingOptions.Mode".PROPOSE && PB.encode(e, 2, x.mode)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CheckRequest.AutonamingOptions")
    encoded_size = 0
    !isempty(x.proposed_name) && (encoded_size += PB._encoded_size(x.proposed_name, 1))
    x.mode != var"CheckRequest.AutonamingOptions.Mode".PROPOSE && (encoded_size += PB._encoded_size(x.mode, 2))
    return encoded_size
end

struct ConstructResponse
    urn::String
    state::Union{Nothing,google.protobuf.Struct}
    stateDependencies::Dict{String,var"ConstructResponse.PropertyDependencies"}
end
PB.default_values(::Type{ConstructResponse}) = (;urn = "", state = nothing, stateDependencies = Dict{String,var"ConstructResponse.PropertyDependencies"}())
PB.field_numbers(::Type{ConstructResponse}) = (;urn = 1, state = 2, stateDependencies = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConstructResponse})
    urn = ""
    state = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    stateDependencies = Dict{String,var"ConstructResponse.PropertyDependencies"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            urn = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, state)
        elseif field_number == 3
            PB.decode!(d, stateDependencies)
        else
            Base.skip(d, wire_type)
        end
    end
    return ConstructResponse(urn, state[], stateDependencies)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConstructResponse)
    initpos = position(e.io)
    !isempty(x.urn) && PB.encode(e, 1, x.urn)
    !isnothing(x.state) && PB.encode(e, 2, x.state)
    !isempty(x.stateDependencies) && PB.encode(e, 3, x.stateDependencies)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConstructResponse)
    encoded_size = 0
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 1))
    !isnothing(x.state) && (encoded_size += PB._encoded_size(x.state, 2))
    !isempty(x.stateDependencies) && (encoded_size += PB._encoded_size(x.stateDependencies, 3))
    return encoded_size
end

struct ConstructRequest
    project::String
    stack::String
    config::Dict{String,String}
    dryRun::Bool
    parallel::Int32
    monitorEndpoint::String
    var"#type"::String
    name::String
    parent::String
    inputs::Union{Nothing,google.protobuf.Struct}
    inputDependencies::Dict{String,var"ConstructRequest.PropertyDependencies"}
    providers::Dict{String,String}
    dependencies::Vector{String}
    configSecretKeys::Vector{String}
    organization::String
    protect::Bool
    aliases::Vector{String}
    additionalSecretOutputs::Vector{String}
    customTimeouts::Union{Nothing,var"ConstructRequest.CustomTimeouts"}
    deletedWith::String
    deleteBeforeReplace::Bool
    ignoreChanges::Vector{String}
    replaceOnChanges::Vector{String}
    retainOnDelete::Bool
    accepts_output_values::Bool
    resource_hooks::Union{Nothing,var"ConstructRequest.ResourceHooksBinding"}
    stack_trace_handle::String
    replace_with::Vector{String}
end
PB.default_values(::Type{ConstructRequest}) = (;project = "", stack = "", config = Dict{String,String}(), dryRun = false, parallel = zero(Int32), monitorEndpoint = "", var"#type" = "", name = "", parent = "", inputs = nothing, inputDependencies = Dict{String,var"ConstructRequest.PropertyDependencies"}(), providers = Dict{String,String}(), dependencies = Vector{String}(), configSecretKeys = Vector{String}(), organization = "", protect = false, aliases = Vector{String}(), additionalSecretOutputs = Vector{String}(), customTimeouts = nothing, deletedWith = "", deleteBeforeReplace = false, ignoreChanges = Vector{String}(), replaceOnChanges = Vector{String}(), retainOnDelete = false, accepts_output_values = false, resource_hooks = nothing, stack_trace_handle = "", replace_with = Vector{String}())
PB.field_numbers(::Type{ConstructRequest}) = (;project = 1, stack = 2, config = 3, dryRun = 4, parallel = 5, monitorEndpoint = 6, var"#type" = 7, name = 8, parent = 9, inputs = 10, inputDependencies = 11, providers = 13, dependencies = 15, configSecretKeys = 16, organization = 17, protect = 12, aliases = 14, additionalSecretOutputs = 18, customTimeouts = 19, deletedWith = 20, deleteBeforeReplace = 21, ignoreChanges = 22, replaceOnChanges = 23, retainOnDelete = 24, accepts_output_values = 25, resource_hooks = 26, stack_trace_handle = 27, replace_with = 28)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConstructRequest})
    project = ""
    stack = ""
    config = Dict{String,String}()
    dryRun = false
    parallel = zero(Int32)
    monitorEndpoint = ""
    var"#type" = ""
    name = ""
    parent = ""
    inputs = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    inputDependencies = Dict{String,var"ConstructRequest.PropertyDependencies"}()
    providers = Dict{String,String}()
    dependencies = PB.BufferedVector{String}()
    configSecretKeys = PB.BufferedVector{String}()
    organization = ""
    protect = false
    aliases = PB.BufferedVector{String}()
    additionalSecretOutputs = PB.BufferedVector{String}()
    customTimeouts = Ref{Union{Nothing,var"ConstructRequest.CustomTimeouts"}}(nothing)
    deletedWith = ""
    deleteBeforeReplace = false
    ignoreChanges = PB.BufferedVector{String}()
    replaceOnChanges = PB.BufferedVector{String}()
    retainOnDelete = false
    accepts_output_values = false
    resource_hooks = Ref{Union{Nothing,var"ConstructRequest.ResourceHooksBinding"}}(nothing)
    stack_trace_handle = ""
    replace_with = PB.BufferedVector{String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            project = PB.decode(d, String)
        elseif field_number == 2
            stack = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, config)
        elseif field_number == 4
            dryRun = PB.decode(d, Bool)
        elseif field_number == 5
            parallel = PB.decode(d, Int32)
        elseif field_number == 6
            monitorEndpoint = PB.decode(d, String)
        elseif field_number == 7
            var"#type" = PB.decode(d, String)
        elseif field_number == 8
            name = PB.decode(d, String)
        elseif field_number == 9
            parent = PB.decode(d, String)
        elseif field_number == 10
            PB.decode!(d, inputs)
        elseif field_number == 11
            PB.decode!(d, inputDependencies)
        elseif field_number == 13
            PB.decode!(d, providers)
        elseif field_number == 15
            PB.decode!(d, dependencies)
        elseif field_number == 16
            PB.decode!(d, configSecretKeys)
        elseif field_number == 17
            organization = PB.decode(d, String)
        elseif field_number == 12
            protect = PB.decode(d, Bool)
        elseif field_number == 14
            PB.decode!(d, aliases)
        elseif field_number == 18
            PB.decode!(d, additionalSecretOutputs)
        elseif field_number == 19
            PB.decode!(d, customTimeouts)
        elseif field_number == 20
            deletedWith = PB.decode(d, String)
        elseif field_number == 21
            deleteBeforeReplace = PB.decode(d, Bool)
        elseif field_number == 22
            PB.decode!(d, ignoreChanges)
        elseif field_number == 23
            PB.decode!(d, replaceOnChanges)
        elseif field_number == 24
            retainOnDelete = PB.decode(d, Bool)
        elseif field_number == 25
            accepts_output_values = PB.decode(d, Bool)
        elseif field_number == 26
            PB.decode!(d, resource_hooks)
        elseif field_number == 27
            stack_trace_handle = PB.decode(d, String)
        elseif field_number == 28
            PB.decode!(d, replace_with)
        else
            Base.skip(d, wire_type)
        end
    end
    return ConstructRequest(project, stack, config, dryRun, parallel, monitorEndpoint, var"#type", name, parent, inputs[], inputDependencies, providers, dependencies[], configSecretKeys[], organization, protect, aliases[], additionalSecretOutputs[], customTimeouts[], deletedWith, deleteBeforeReplace, ignoreChanges[], replaceOnChanges[], retainOnDelete, accepts_output_values, resource_hooks[], stack_trace_handle, replace_with[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConstructRequest)
    initpos = position(e.io)
    !isempty(x.project) && PB.encode(e, 1, x.project)
    !isempty(x.stack) && PB.encode(e, 2, x.stack)
    !isempty(x.config) && PB.encode(e, 3, x.config)
    x.dryRun != false && PB.encode(e, 4, x.dryRun)
    x.parallel != zero(Int32) && PB.encode(e, 5, x.parallel)
    !isempty(x.monitorEndpoint) && PB.encode(e, 6, x.monitorEndpoint)
    !isempty(x.var"#type") && PB.encode(e, 7, x.var"#type")
    !isempty(x.name) && PB.encode(e, 8, x.name)
    !isempty(x.parent) && PB.encode(e, 9, x.parent)
    !isnothing(x.inputs) && PB.encode(e, 10, x.inputs)
    !isempty(x.inputDependencies) && PB.encode(e, 11, x.inputDependencies)
    !isempty(x.providers) && PB.encode(e, 13, x.providers)
    !isempty(x.dependencies) && PB.encode(e, 15, x.dependencies)
    !isempty(x.configSecretKeys) && PB.encode(e, 16, x.configSecretKeys)
    !isempty(x.organization) && PB.encode(e, 17, x.organization)
    x.protect != false && PB.encode(e, 12, x.protect)
    !isempty(x.aliases) && PB.encode(e, 14, x.aliases)
    !isempty(x.additionalSecretOutputs) && PB.encode(e, 18, x.additionalSecretOutputs)
    !isnothing(x.customTimeouts) && PB.encode(e, 19, x.customTimeouts)
    !isempty(x.deletedWith) && PB.encode(e, 20, x.deletedWith)
    x.deleteBeforeReplace != false && PB.encode(e, 21, x.deleteBeforeReplace)
    !isempty(x.ignoreChanges) && PB.encode(e, 22, x.ignoreChanges)
    !isempty(x.replaceOnChanges) && PB.encode(e, 23, x.replaceOnChanges)
    x.retainOnDelete != false && PB.encode(e, 24, x.retainOnDelete)
    x.accepts_output_values != false && PB.encode(e, 25, x.accepts_output_values)
    !isnothing(x.resource_hooks) && PB.encode(e, 26, x.resource_hooks)
    !isempty(x.stack_trace_handle) && PB.encode(e, 27, x.stack_trace_handle)
    !isempty(x.replace_with) && PB.encode(e, 28, x.replace_with)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConstructRequest)
    encoded_size = 0
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 1))
    !isempty(x.stack) && (encoded_size += PB._encoded_size(x.stack, 2))
    !isempty(x.config) && (encoded_size += PB._encoded_size(x.config, 3))
    x.dryRun != false && (encoded_size += PB._encoded_size(x.dryRun, 4))
    x.parallel != zero(Int32) && (encoded_size += PB._encoded_size(x.parallel, 5))
    !isempty(x.monitorEndpoint) && (encoded_size += PB._encoded_size(x.monitorEndpoint, 6))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 7))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 8))
    !isempty(x.parent) && (encoded_size += PB._encoded_size(x.parent, 9))
    !isnothing(x.inputs) && (encoded_size += PB._encoded_size(x.inputs, 10))
    !isempty(x.inputDependencies) && (encoded_size += PB._encoded_size(x.inputDependencies, 11))
    !isempty(x.providers) && (encoded_size += PB._encoded_size(x.providers, 13))
    !isempty(x.dependencies) && (encoded_size += PB._encoded_size(x.dependencies, 15))
    !isempty(x.configSecretKeys) && (encoded_size += PB._encoded_size(x.configSecretKeys, 16))
    !isempty(x.organization) && (encoded_size += PB._encoded_size(x.organization, 17))
    x.protect != false && (encoded_size += PB._encoded_size(x.protect, 12))
    !isempty(x.aliases) && (encoded_size += PB._encoded_size(x.aliases, 14))
    !isempty(x.additionalSecretOutputs) && (encoded_size += PB._encoded_size(x.additionalSecretOutputs, 18))
    !isnothing(x.customTimeouts) && (encoded_size += PB._encoded_size(x.customTimeouts, 19))
    !isempty(x.deletedWith) && (encoded_size += PB._encoded_size(x.deletedWith, 20))
    x.deleteBeforeReplace != false && (encoded_size += PB._encoded_size(x.deleteBeforeReplace, 21))
    !isempty(x.ignoreChanges) && (encoded_size += PB._encoded_size(x.ignoreChanges, 22))
    !isempty(x.replaceOnChanges) && (encoded_size += PB._encoded_size(x.replaceOnChanges, 23))
    x.retainOnDelete != false && (encoded_size += PB._encoded_size(x.retainOnDelete, 24))
    x.accepts_output_values != false && (encoded_size += PB._encoded_size(x.accepts_output_values, 25))
    !isnothing(x.resource_hooks) && (encoded_size += PB._encoded_size(x.resource_hooks, 26))
    !isempty(x.stack_trace_handle) && (encoded_size += PB._encoded_size(x.stack_trace_handle, 27))
    !isempty(x.replace_with) && (encoded_size += PB._encoded_size(x.replace_with, 28))
    return encoded_size
end

struct DiffResponse
    replaces::Vector{String}
    stables::Vector{String}
    deleteBeforeReplace::Bool
    changes::var"DiffResponse.DiffChanges".T
    diffs::Vector{String}
    detailedDiff::Dict{String,PropertyDiff}
    hasDetailedDiff::Bool
end
PB.default_values(::Type{DiffResponse}) = (;replaces = Vector{String}(), stables = Vector{String}(), deleteBeforeReplace = false, changes = var"DiffResponse.DiffChanges".DIFF_UNKNOWN, diffs = Vector{String}(), detailedDiff = Dict{String,PropertyDiff}(), hasDetailedDiff = false)
PB.field_numbers(::Type{DiffResponse}) = (;replaces = 1, stables = 2, deleteBeforeReplace = 3, changes = 4, diffs = 5, detailedDiff = 6, hasDetailedDiff = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DiffResponse})
    replaces = PB.BufferedVector{String}()
    stables = PB.BufferedVector{String}()
    deleteBeforeReplace = false
    changes = var"DiffResponse.DiffChanges".DIFF_UNKNOWN
    diffs = PB.BufferedVector{String}()
    detailedDiff = Dict{String,PropertyDiff}()
    hasDetailedDiff = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, replaces)
        elseif field_number == 2
            PB.decode!(d, stables)
        elseif field_number == 3
            deleteBeforeReplace = PB.decode(d, Bool)
        elseif field_number == 4
            changes = PB.decode(d, var"DiffResponse.DiffChanges".T)
        elseif field_number == 5
            PB.decode!(d, diffs)
        elseif field_number == 6
            PB.decode!(d, detailedDiff)
        elseif field_number == 7
            hasDetailedDiff = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return DiffResponse(replaces[], stables[], deleteBeforeReplace, changes, diffs[], detailedDiff, hasDetailedDiff)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DiffResponse)
    initpos = position(e.io)
    !isempty(x.replaces) && PB.encode(e, 1, x.replaces)
    !isempty(x.stables) && PB.encode(e, 2, x.stables)
    x.deleteBeforeReplace != false && PB.encode(e, 3, x.deleteBeforeReplace)
    x.changes != var"DiffResponse.DiffChanges".DIFF_UNKNOWN && PB.encode(e, 4, x.changes)
    !isempty(x.diffs) && PB.encode(e, 5, x.diffs)
    !isempty(x.detailedDiff) && PB.encode(e, 6, x.detailedDiff)
    x.hasDetailedDiff != false && PB.encode(e, 7, x.hasDetailedDiff)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DiffResponse)
    encoded_size = 0
    !isempty(x.replaces) && (encoded_size += PB._encoded_size(x.replaces, 1))
    !isempty(x.stables) && (encoded_size += PB._encoded_size(x.stables, 2))
    x.deleteBeforeReplace != false && (encoded_size += PB._encoded_size(x.deleteBeforeReplace, 3))
    x.changes != var"DiffResponse.DiffChanges".DIFF_UNKNOWN && (encoded_size += PB._encoded_size(x.changes, 4))
    !isempty(x.diffs) && (encoded_size += PB._encoded_size(x.diffs, 5))
    !isempty(x.detailedDiff) && (encoded_size += PB._encoded_size(x.detailedDiff, 6))
    x.hasDetailedDiff != false && (encoded_size += PB._encoded_size(x.hasDetailedDiff, 7))
    return encoded_size
end

struct CheckRequest
    urn::String
    olds::Union{Nothing,google.protobuf.Struct}
    news::Union{Nothing,google.protobuf.Struct}
    randomSeed::Vector{UInt8}
    name::String
    var"#type"::String
    autonaming::Union{Nothing,var"CheckRequest.AutonamingOptions"}
end
PB.reserved_fields(::Type{CheckRequest}) = (names = ["sequenceNumber"], numbers = Union{Int,UnitRange{Int}}[4])
PB.default_values(::Type{CheckRequest}) = (;urn = "", olds = nothing, news = nothing, randomSeed = UInt8[], name = "", var"#type" = "", autonaming = nothing)
PB.field_numbers(::Type{CheckRequest}) = (;urn = 1, olds = 2, news = 3, randomSeed = 5, name = 6, var"#type" = 7, autonaming = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CheckRequest})
    urn = ""
    olds = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    news = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    randomSeed = UInt8[]
    name = ""
    var"#type" = ""
    autonaming = Ref{Union{Nothing,var"CheckRequest.AutonamingOptions"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            urn = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, olds)
        elseif field_number == 3
            PB.decode!(d, news)
        elseif field_number == 5
            randomSeed = PB.decode(d, Vector{UInt8})
        elseif field_number == 6
            name = PB.decode(d, String)
        elseif field_number == 7
            var"#type" = PB.decode(d, String)
        elseif field_number == 8
            PB.decode!(d, autonaming)
        else
            Base.skip(d, wire_type)
        end
    end
    return CheckRequest(urn, olds[], news[], randomSeed, name, var"#type", autonaming[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CheckRequest)
    initpos = position(e.io)
    !isempty(x.urn) && PB.encode(e, 1, x.urn)
    !isnothing(x.olds) && PB.encode(e, 2, x.olds)
    !isnothing(x.news) && PB.encode(e, 3, x.news)
    !isempty(x.randomSeed) && PB.encode(e, 5, x.randomSeed)
    !isempty(x.name) && PB.encode(e, 6, x.name)
    !isempty(x.var"#type") && PB.encode(e, 7, x.var"#type")
    !isnothing(x.autonaming) && PB.encode(e, 8, x.autonaming)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CheckRequest)
    encoded_size = 0
    !isempty(x.urn) && (encoded_size += PB._encoded_size(x.urn, 1))
    !isnothing(x.olds) && (encoded_size += PB._encoded_size(x.olds, 2))
    !isnothing(x.news) && (encoded_size += PB._encoded_size(x.news, 3))
    !isempty(x.randomSeed) && (encoded_size += PB._encoded_size(x.randomSeed, 5))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 6))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 7))
    !isnothing(x.autonaming) && (encoded_size += PB._encoded_size(x.autonaming, 8))
    return encoded_size
end

# TODO: SERVICE
#    ResourceProvider
