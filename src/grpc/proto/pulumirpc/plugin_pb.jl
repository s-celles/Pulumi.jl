# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-10T09:19:32.578
# original file: /home/scelles-admin/.julia/dev/Pulumi/proto/pulumi/plugin.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export PackageParameterization, PluginAttach, PluginDependency, PluginInfo
export PackageDependency


struct PackageParameterization
    name::String
    version::String
    value::Vector{UInt8}
end
PB.default_values(::Type{PackageParameterization}) = (;name = "", version = "", value = UInt8[])
PB.field_numbers(::Type{PackageParameterization}) = (;name = 1, version = 2, value = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PackageParameterization})
    name = ""
    version = ""
    value = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        elseif field_number == 3
            value = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return PackageParameterization(name, version, value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PackageParameterization)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    !isempty(x.value) && PB.encode(e, 3, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PackageParameterization)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    !isempty(x.value) && (encoded_size += PB._encoded_size(x.value, 3))
    return encoded_size
end

struct PluginAttach
    address::String
end
PB.default_values(::Type{PluginAttach}) = (;address = "")
PB.field_numbers(::Type{PluginAttach}) = (;address = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PluginAttach})
    address = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            address = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return PluginAttach(address)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PluginAttach)
    initpos = position(e.io)
    !isempty(x.address) && PB.encode(e, 1, x.address)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PluginAttach)
    encoded_size = 0
    !isempty(x.address) && (encoded_size += PB._encoded_size(x.address, 1))
    return encoded_size
end

struct PluginDependency
    name::String
    kind::String
    version::String
    server::String
    checksums::Dict{String,Vector{UInt8}}
end
PB.default_values(::Type{PluginDependency}) = (;name = "", kind = "", version = "", server = "", checksums = Dict{String,Vector{UInt8}}())
PB.field_numbers(::Type{PluginDependency}) = (;name = 1, kind = 2, version = 3, server = 4, checksums = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PluginDependency})
    name = ""
    kind = ""
    version = ""
    server = ""
    checksums = Dict{String,Vector{UInt8}}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            kind = PB.decode(d, String)
        elseif field_number == 3
            version = PB.decode(d, String)
        elseif field_number == 4
            server = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, checksums)
        else
            Base.skip(d, wire_type)
        end
    end
    return PluginDependency(name, kind, version, server, checksums)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PluginDependency)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.kind) && PB.encode(e, 2, x.kind)
    !isempty(x.version) && PB.encode(e, 3, x.version)
    !isempty(x.server) && PB.encode(e, 4, x.server)
    !isempty(x.checksums) && PB.encode(e, 5, x.checksums)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PluginDependency)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.kind) && (encoded_size += PB._encoded_size(x.kind, 2))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 3))
    !isempty(x.server) && (encoded_size += PB._encoded_size(x.server, 4))
    !isempty(x.checksums) && (encoded_size += PB._encoded_size(x.checksums, 5))
    return encoded_size
end

struct PluginInfo
    version::String
end
PB.default_values(::Type{PluginInfo}) = (;version = "")
PB.field_numbers(::Type{PluginInfo}) = (;version = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PluginInfo})
    version = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            version = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return PluginInfo(version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PluginInfo)
    initpos = position(e.io)
    !isempty(x.version) && PB.encode(e, 1, x.version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PluginInfo)
    encoded_size = 0
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 1))
    return encoded_size
end

struct PackageDependency
    name::String
    kind::String
    version::String
    server::String
    checksums::Dict{String,Vector{UInt8}}
    parameterization::Union{Nothing,PackageParameterization}
end
PB.default_values(::Type{PackageDependency}) = (;name = "", kind = "", version = "", server = "", checksums = Dict{String,Vector{UInt8}}(), parameterization = nothing)
PB.field_numbers(::Type{PackageDependency}) = (;name = 1, kind = 2, version = 3, server = 4, checksums = 5, parameterization = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PackageDependency})
    name = ""
    kind = ""
    version = ""
    server = ""
    checksums = Dict{String,Vector{UInt8}}()
    parameterization = Ref{Union{Nothing,PackageParameterization}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            kind = PB.decode(d, String)
        elseif field_number == 3
            version = PB.decode(d, String)
        elseif field_number == 4
            server = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, checksums)
        elseif field_number == 6
            PB.decode!(d, parameterization)
        else
            Base.skip(d, wire_type)
        end
    end
    return PackageDependency(name, kind, version, server, checksums, parameterization[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PackageDependency)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.kind) && PB.encode(e, 2, x.kind)
    !isempty(x.version) && PB.encode(e, 3, x.version)
    !isempty(x.server) && PB.encode(e, 4, x.server)
    !isempty(x.checksums) && PB.encode(e, 5, x.checksums)
    !isnothing(x.parameterization) && PB.encode(e, 6, x.parameterization)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PackageDependency)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.kind) && (encoded_size += PB._encoded_size(x.kind, 2))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 3))
    !isempty(x.server) && (encoded_size += PB._encoded_size(x.server, 4))
    !isempty(x.checksums) && (encoded_size += PB._encoded_size(x.checksums, 5))
    !isnothing(x.parameterization) && (encoded_size += PB._encoded_size(x.parameterization, 6))
    return encoded_size
end
