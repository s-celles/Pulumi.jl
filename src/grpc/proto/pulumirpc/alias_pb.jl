# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-10T11:23:19.190
# original file: /home/scelles-admin/.julia/dev/Pulumi/proto/pulumi/alias.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"Alias.Spec", Alias


struct var"Alias.Spec"
    name::String
    var"#type"::String
    stack::String
    project::String
    parent::Union{Nothing,OneOf{<:Union{String,Bool}}}
end
PB.oneof_field_types(::Type{var"Alias.Spec"}) = (;
    parent = (;parentUrn=String, noParent=Bool),
)
PB.default_values(::Type{var"Alias.Spec"}) = (;name = "", var"#type" = "", stack = "", project = "", parentUrn = "", noParent = false)
PB.field_numbers(::Type{var"Alias.Spec"}) = (;name = 1, var"#type" = 2, stack = 3, project = 4, parentUrn = 5, noParent = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"Alias.Spec"})
    name = ""
    var"#type" = ""
    stack = ""
    project = ""
    parent = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            var"#type" = PB.decode(d, String)
        elseif field_number == 3
            stack = PB.decode(d, String)
        elseif field_number == 4
            project = PB.decode(d, String)
        elseif field_number == 5
            parent = OneOf(:parentUrn, PB.decode(d, String))
        elseif field_number == 6
            parent = OneOf(:noParent, PB.decode(d, Bool))
        else
            Base.skip(d, wire_type)
        end
    end
    return var"Alias.Spec"(name, var"#type", stack, project, parent)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"Alias.Spec")
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.var"#type") && PB.encode(e, 2, x.var"#type")
    !isempty(x.stack) && PB.encode(e, 3, x.stack)
    !isempty(x.project) && PB.encode(e, 4, x.project)
    if isnothing(x.parent);
    elseif x.parent.name === :parentUrn
        PB.encode(e, 5, x.parent[]::String)
    elseif x.parent.name === :noParent
        PB.encode(e, 6, x.parent[]::Bool)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"Alias.Spec")
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.var"#type") && (encoded_size += PB._encoded_size(x.var"#type", 2))
    !isempty(x.stack) && (encoded_size += PB._encoded_size(x.stack, 3))
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 4))
    if isnothing(x.parent);
    elseif x.parent.name === :parentUrn
        encoded_size += PB._encoded_size(x.parent[]::String, 5)
    elseif x.parent.name === :noParent
        encoded_size += PB._encoded_size(x.parent[]::Bool, 6)
    end
    return encoded_size
end

struct Alias
    alias::Union{Nothing,OneOf{<:Union{String,var"Alias.Spec"}}}
end
PB.oneof_field_types(::Type{Alias}) = (;
    alias = (;urn=String, spec=var"Alias.Spec"),
)
PB.default_values(::Type{Alias}) = (;urn = "", spec = nothing)
PB.field_numbers(::Type{Alias}) = (;urn = 1, spec = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Alias})
    alias = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            alias = OneOf(:urn, PB.decode(d, String))
        elseif field_number == 2
            alias = OneOf(:spec, PB.decode(d, Ref{var"Alias.Spec"}))
        else
            Base.skip(d, wire_type)
        end
    end
    return Alias(alias)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Alias)
    initpos = position(e.io)
    if isnothing(x.alias);
    elseif x.alias.name === :urn
        PB.encode(e, 1, x.alias[]::String)
    elseif x.alias.name === :spec
        PB.encode(e, 2, x.alias[]::var"Alias.Spec")
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::Alias)
    encoded_size = 0
    if isnothing(x.alias);
    elseif x.alias.name === :urn
        encoded_size += PB._encoded_size(x.alias[]::String, 1)
    elseif x.alias.name === :spec
        encoded_size += PB._encoded_size(x.alias[]::var"Alias.Spec", 2)
    end
    return encoded_size
end
