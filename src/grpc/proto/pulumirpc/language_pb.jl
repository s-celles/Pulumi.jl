# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-10T11:23:19.546
# original file: /home/scelles-admin/.julia/dev/Pulumi/proto/language.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export TemplateResponse, GenerateProjectResponse, LanguageHandshakeRequest
export InstallDependenciesResponse, ProgramInfo, GetRequiredPackagesResponse
export GeneratePackageResponse, RunPluginResponse, AboutResponse, RunResponse
export GenerateProjectRequest, LanguageHandshakeResponse, GeneratePackageRequest
export LinkResponse, PackResponse, var"RuntimeOptionPrompt.RuntimeOptionType", PackRequest
export DependencyInfo, GenerateProgramResponse, GetRequiredPluginsResponse
export GenerateProgramRequest, var"LinkRequest.LinkDependency"
export GetProgramDependenciesRequest, RuntimeOptionsRequest, TemplateRequest
export GetRequiredPluginsRequest, RunRequest, InstallDependenciesRequest, RunPluginRequest
export AboutRequest, GetRequiredPackagesRequest
export var"RuntimeOptionPrompt.RuntimeOptionValue", GetProgramDependenciesResponse
export LinkRequest, RuntimeOptionPrompt, RuntimeOptionsResponse


struct TemplateResponse end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TemplateResponse})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return TemplateResponse()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TemplateResponse)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TemplateResponse)
    encoded_size = 0
    return encoded_size
end

struct GenerateProjectResponse
    diagnostics::Vector{pulumirpc.codegen.Diagnostic}
end
PB.default_values(::Type{GenerateProjectResponse}) = (;diagnostics = Vector{pulumirpc.codegen.Diagnostic}())
PB.field_numbers(::Type{GenerateProjectResponse}) = (;diagnostics = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GenerateProjectResponse})
    diagnostics = PB.BufferedVector{pulumirpc.codegen.Diagnostic}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, diagnostics)
        else
            Base.skip(d, wire_type)
        end
    end
    return GenerateProjectResponse(diagnostics[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GenerateProjectResponse)
    initpos = position(e.io)
    !isempty(x.diagnostics) && PB.encode(e, 1, x.diagnostics)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GenerateProjectResponse)
    encoded_size = 0
    !isempty(x.diagnostics) && (encoded_size += PB._encoded_size(x.diagnostics, 1))
    return encoded_size
end

struct LanguageHandshakeRequest
    engine_address::String
    root_directory::String
    program_directory::String
end
PB.default_values(::Type{LanguageHandshakeRequest}) = (;engine_address = "", root_directory = "", program_directory = "")
PB.field_numbers(::Type{LanguageHandshakeRequest}) = (;engine_address = 1, root_directory = 2, program_directory = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LanguageHandshakeRequest})
    engine_address = ""
    root_directory = ""
    program_directory = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            engine_address = PB.decode(d, String)
        elseif field_number == 2
            root_directory = PB.decode(d, String)
        elseif field_number == 3
            program_directory = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return LanguageHandshakeRequest(engine_address, root_directory, program_directory)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LanguageHandshakeRequest)
    initpos = position(e.io)
    !isempty(x.engine_address) && PB.encode(e, 1, x.engine_address)
    !isempty(x.root_directory) && PB.encode(e, 2, x.root_directory)
    !isempty(x.program_directory) && PB.encode(e, 3, x.program_directory)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LanguageHandshakeRequest)
    encoded_size = 0
    !isempty(x.engine_address) && (encoded_size += PB._encoded_size(x.engine_address, 1))
    !isempty(x.root_directory) && (encoded_size += PB._encoded_size(x.root_directory, 2))
    !isempty(x.program_directory) && (encoded_size += PB._encoded_size(x.program_directory, 3))
    return encoded_size
end

struct InstallDependenciesResponse
    stdout::Vector{UInt8}
    stderr::Vector{UInt8}
end
PB.default_values(::Type{InstallDependenciesResponse}) = (;stdout = UInt8[], stderr = UInt8[])
PB.field_numbers(::Type{InstallDependenciesResponse}) = (;stdout = 1, stderr = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InstallDependenciesResponse})
    stdout = UInt8[]
    stderr = UInt8[]
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            stdout = PB.decode(d, Vector{UInt8})
        elseif field_number == 2
            stderr = PB.decode(d, Vector{UInt8})
        else
            Base.skip(d, wire_type)
        end
    end
    return InstallDependenciesResponse(stdout, stderr)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InstallDependenciesResponse)
    initpos = position(e.io)
    !isempty(x.stdout) && PB.encode(e, 1, x.stdout)
    !isempty(x.stderr) && PB.encode(e, 2, x.stderr)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InstallDependenciesResponse)
    encoded_size = 0
    !isempty(x.stdout) && (encoded_size += PB._encoded_size(x.stdout, 1))
    !isempty(x.stderr) && (encoded_size += PB._encoded_size(x.stderr, 2))
    return encoded_size
end

struct ProgramInfo
    root_directory::String
    program_directory::String
    entry_point::String
    options::Union{Nothing,google.protobuf.Struct}
end
PB.default_values(::Type{ProgramInfo}) = (;root_directory = "", program_directory = "", entry_point = "", options = nothing)
PB.field_numbers(::Type{ProgramInfo}) = (;root_directory = 1, program_directory = 2, entry_point = 3, options = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ProgramInfo})
    root_directory = ""
    program_directory = ""
    entry_point = ""
    options = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            root_directory = PB.decode(d, String)
        elseif field_number == 2
            program_directory = PB.decode(d, String)
        elseif field_number == 3
            entry_point = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, options)
        else
            Base.skip(d, wire_type)
        end
    end
    return ProgramInfo(root_directory, program_directory, entry_point, options[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ProgramInfo)
    initpos = position(e.io)
    !isempty(x.root_directory) && PB.encode(e, 1, x.root_directory)
    !isempty(x.program_directory) && PB.encode(e, 2, x.program_directory)
    !isempty(x.entry_point) && PB.encode(e, 3, x.entry_point)
    !isnothing(x.options) && PB.encode(e, 4, x.options)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ProgramInfo)
    encoded_size = 0
    !isempty(x.root_directory) && (encoded_size += PB._encoded_size(x.root_directory, 1))
    !isempty(x.program_directory) && (encoded_size += PB._encoded_size(x.program_directory, 2))
    !isempty(x.entry_point) && (encoded_size += PB._encoded_size(x.entry_point, 3))
    !isnothing(x.options) && (encoded_size += PB._encoded_size(x.options, 4))
    return encoded_size
end

struct GetRequiredPackagesResponse
    packages::Vector{PackageDependency}
end
PB.default_values(::Type{GetRequiredPackagesResponse}) = (;packages = Vector{PackageDependency}())
PB.field_numbers(::Type{GetRequiredPackagesResponse}) = (;packages = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetRequiredPackagesResponse})
    packages = PB.BufferedVector{PackageDependency}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, packages)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetRequiredPackagesResponse(packages[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetRequiredPackagesResponse)
    initpos = position(e.io)
    !isempty(x.packages) && PB.encode(e, 1, x.packages)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetRequiredPackagesResponse)
    encoded_size = 0
    !isempty(x.packages) && (encoded_size += PB._encoded_size(x.packages, 1))
    return encoded_size
end

struct GeneratePackageResponse
    diagnostics::Vector{pulumirpc.codegen.Diagnostic}
end
PB.default_values(::Type{GeneratePackageResponse}) = (;diagnostics = Vector{pulumirpc.codegen.Diagnostic}())
PB.field_numbers(::Type{GeneratePackageResponse}) = (;diagnostics = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GeneratePackageResponse})
    diagnostics = PB.BufferedVector{pulumirpc.codegen.Diagnostic}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, diagnostics)
        else
            Base.skip(d, wire_type)
        end
    end
    return GeneratePackageResponse(diagnostics[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GeneratePackageResponse)
    initpos = position(e.io)
    !isempty(x.diagnostics) && PB.encode(e, 1, x.diagnostics)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GeneratePackageResponse)
    encoded_size = 0
    !isempty(x.diagnostics) && (encoded_size += PB._encoded_size(x.diagnostics, 1))
    return encoded_size
end

struct RunPluginResponse
    output::Union{Nothing,OneOf{<:Union{Vector{UInt8},Int32}}}
end
PB.oneof_field_types(::Type{RunPluginResponse}) = (;
    output = (;stdout=Vector{UInt8}, stderr=Vector{UInt8}, exitcode=Int32),
)
PB.default_values(::Type{RunPluginResponse}) = (;stdout = UInt8[], stderr = UInt8[], exitcode = zero(Int32))
PB.field_numbers(::Type{RunPluginResponse}) = (;stdout = 1, stderr = 2, exitcode = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RunPluginResponse})
    output = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            output = OneOf(:stdout, PB.decode(d, Vector{UInt8}))
        elseif field_number == 2
            output = OneOf(:stderr, PB.decode(d, Vector{UInt8}))
        elseif field_number == 3
            output = OneOf(:exitcode, PB.decode(d, Int32))
        else
            Base.skip(d, wire_type)
        end
    end
    return RunPluginResponse(output)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RunPluginResponse)
    initpos = position(e.io)
    if isnothing(x.output);
    elseif x.output.name === :stdout
        PB.encode(e, 1, x.output[]::Vector{UInt8})
    elseif x.output.name === :stderr
        PB.encode(e, 2, x.output[]::Vector{UInt8})
    elseif x.output.name === :exitcode
        PB.encode(e, 3, x.output[]::Int32)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::RunPluginResponse)
    encoded_size = 0
    if isnothing(x.output);
    elseif x.output.name === :stdout
        encoded_size += PB._encoded_size(x.output[]::Vector{UInt8}, 1)
    elseif x.output.name === :stderr
        encoded_size += PB._encoded_size(x.output[]::Vector{UInt8}, 2)
    elseif x.output.name === :exitcode
        encoded_size += PB._encoded_size(x.output[]::Int32, 3)
    end
    return encoded_size
end

struct AboutResponse
    executable::String
    version::String
    metadata::Dict{String,String}
end
PB.default_values(::Type{AboutResponse}) = (;executable = "", version = "", metadata = Dict{String,String}())
PB.field_numbers(::Type{AboutResponse}) = (;executable = 1, version = 2, metadata = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AboutResponse})
    executable = ""
    version = ""
    metadata = Dict{String,String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            executable = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, metadata)
        else
            Base.skip(d, wire_type)
        end
    end
    return AboutResponse(executable, version, metadata)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AboutResponse)
    initpos = position(e.io)
    !isempty(x.executable) && PB.encode(e, 1, x.executable)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    !isempty(x.metadata) && PB.encode(e, 3, x.metadata)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AboutResponse)
    encoded_size = 0
    !isempty(x.executable) && (encoded_size += PB._encoded_size(x.executable, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    !isempty(x.metadata) && (encoded_size += PB._encoded_size(x.metadata, 3))
    return encoded_size
end

struct RunResponse
    error::String
    bail::Bool
end
PB.default_values(::Type{RunResponse}) = (;error = "", bail = false)
PB.field_numbers(::Type{RunResponse}) = (;error = 1, bail = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RunResponse})
    error = ""
    bail = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            error = PB.decode(d, String)
        elseif field_number == 2
            bail = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return RunResponse(error, bail)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RunResponse)
    initpos = position(e.io)
    !isempty(x.error) && PB.encode(e, 1, x.error)
    x.bail != false && PB.encode(e, 2, x.bail)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RunResponse)
    encoded_size = 0
    !isempty(x.error) && (encoded_size += PB._encoded_size(x.error, 1))
    x.bail != false && (encoded_size += PB._encoded_size(x.bail, 2))
    return encoded_size
end

struct GenerateProjectRequest
    source_directory::String
    target_directory::String
    project::String
    strict::Bool
    loader_target::String
    local_dependencies::Dict{String,String}
end
PB.default_values(::Type{GenerateProjectRequest}) = (;source_directory = "", target_directory = "", project = "", strict = false, loader_target = "", local_dependencies = Dict{String,String}())
PB.field_numbers(::Type{GenerateProjectRequest}) = (;source_directory = 1, target_directory = 2, project = 3, strict = 4, loader_target = 5, local_dependencies = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GenerateProjectRequest})
    source_directory = ""
    target_directory = ""
    project = ""
    strict = false
    loader_target = ""
    local_dependencies = Dict{String,String}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            source_directory = PB.decode(d, String)
        elseif field_number == 2
            target_directory = PB.decode(d, String)
        elseif field_number == 3
            project = PB.decode(d, String)
        elseif field_number == 4
            strict = PB.decode(d, Bool)
        elseif field_number == 5
            loader_target = PB.decode(d, String)
        elseif field_number == 6
            PB.decode!(d, local_dependencies)
        else
            Base.skip(d, wire_type)
        end
    end
    return GenerateProjectRequest(source_directory, target_directory, project, strict, loader_target, local_dependencies)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GenerateProjectRequest)
    initpos = position(e.io)
    !isempty(x.source_directory) && PB.encode(e, 1, x.source_directory)
    !isempty(x.target_directory) && PB.encode(e, 2, x.target_directory)
    !isempty(x.project) && PB.encode(e, 3, x.project)
    x.strict != false && PB.encode(e, 4, x.strict)
    !isempty(x.loader_target) && PB.encode(e, 5, x.loader_target)
    !isempty(x.local_dependencies) && PB.encode(e, 6, x.local_dependencies)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GenerateProjectRequest)
    encoded_size = 0
    !isempty(x.source_directory) && (encoded_size += PB._encoded_size(x.source_directory, 1))
    !isempty(x.target_directory) && (encoded_size += PB._encoded_size(x.target_directory, 2))
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 3))
    x.strict != false && (encoded_size += PB._encoded_size(x.strict, 4))
    !isempty(x.loader_target) && (encoded_size += PB._encoded_size(x.loader_target, 5))
    !isempty(x.local_dependencies) && (encoded_size += PB._encoded_size(x.local_dependencies, 6))
    return encoded_size
end

struct LanguageHandshakeResponse end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LanguageHandshakeResponse})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        Base.skip(d, wire_type)
    end
    return LanguageHandshakeResponse()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LanguageHandshakeResponse)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LanguageHandshakeResponse)
    encoded_size = 0
    return encoded_size
end

struct GeneratePackageRequest
    directory::String
    schema::String
    extra_files::Dict{String,Vector{UInt8}}
    loader_target::String
    local_dependencies::Dict{String,String}
    var"#local"::Bool
end
PB.default_values(::Type{GeneratePackageRequest}) = (;directory = "", schema = "", extra_files = Dict{String,Vector{UInt8}}(), loader_target = "", local_dependencies = Dict{String,String}(), var"#local" = false)
PB.field_numbers(::Type{GeneratePackageRequest}) = (;directory = 1, schema = 2, extra_files = 3, loader_target = 4, local_dependencies = 5, var"#local" = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GeneratePackageRequest})
    directory = ""
    schema = ""
    extra_files = Dict{String,Vector{UInt8}}()
    loader_target = ""
    local_dependencies = Dict{String,String}()
    var"#local" = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            directory = PB.decode(d, String)
        elseif field_number == 2
            schema = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, extra_files)
        elseif field_number == 4
            loader_target = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, local_dependencies)
        elseif field_number == 6
            var"#local" = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return GeneratePackageRequest(directory, schema, extra_files, loader_target, local_dependencies, var"#local")
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GeneratePackageRequest)
    initpos = position(e.io)
    !isempty(x.directory) && PB.encode(e, 1, x.directory)
    !isempty(x.schema) && PB.encode(e, 2, x.schema)
    !isempty(x.extra_files) && PB.encode(e, 3, x.extra_files)
    !isempty(x.loader_target) && PB.encode(e, 4, x.loader_target)
    !isempty(x.local_dependencies) && PB.encode(e, 5, x.local_dependencies)
    x.var"#local" != false && PB.encode(e, 6, x.var"#local")
    return position(e.io) - initpos
end
function PB._encoded_size(x::GeneratePackageRequest)
    encoded_size = 0
    !isempty(x.directory) && (encoded_size += PB._encoded_size(x.directory, 1))
    !isempty(x.schema) && (encoded_size += PB._encoded_size(x.schema, 2))
    !isempty(x.extra_files) && (encoded_size += PB._encoded_size(x.extra_files, 3))
    !isempty(x.loader_target) && (encoded_size += PB._encoded_size(x.loader_target, 4))
    !isempty(x.local_dependencies) && (encoded_size += PB._encoded_size(x.local_dependencies, 5))
    x.var"#local" != false && (encoded_size += PB._encoded_size(x.var"#local", 6))
    return encoded_size
end

struct LinkResponse
    import_instructions::String
end
PB.default_values(::Type{LinkResponse}) = (;import_instructions = "")
PB.field_numbers(::Type{LinkResponse}) = (;import_instructions = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkResponse})
    import_instructions = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            import_instructions = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return LinkResponse(import_instructions)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkResponse)
    initpos = position(e.io)
    !isempty(x.import_instructions) && PB.encode(e, 1, x.import_instructions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkResponse)
    encoded_size = 0
    !isempty(x.import_instructions) && (encoded_size += PB._encoded_size(x.import_instructions, 1))
    return encoded_size
end

struct PackResponse
    artifact_path::String
end
PB.default_values(::Type{PackResponse}) = (;artifact_path = "")
PB.field_numbers(::Type{PackResponse}) = (;artifact_path = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PackResponse})
    artifact_path = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            artifact_path = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return PackResponse(artifact_path)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PackResponse)
    initpos = position(e.io)
    !isempty(x.artifact_path) && PB.encode(e, 1, x.artifact_path)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PackResponse)
    encoded_size = 0
    !isempty(x.artifact_path) && (encoded_size += PB._encoded_size(x.artifact_path, 1))
    return encoded_size
end

@enumx var"RuntimeOptionPrompt.RuntimeOptionType" STRING=0 INT32=1

struct PackRequest
    package_directory::String
    destination_directory::String
end
PB.default_values(::Type{PackRequest}) = (;package_directory = "", destination_directory = "")
PB.field_numbers(::Type{PackRequest}) = (;package_directory = 1, destination_directory = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PackRequest})
    package_directory = ""
    destination_directory = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            package_directory = PB.decode(d, String)
        elseif field_number == 2
            destination_directory = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return PackRequest(package_directory, destination_directory)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PackRequest)
    initpos = position(e.io)
    !isempty(x.package_directory) && PB.encode(e, 1, x.package_directory)
    !isempty(x.destination_directory) && PB.encode(e, 2, x.destination_directory)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PackRequest)
    encoded_size = 0
    !isempty(x.package_directory) && (encoded_size += PB._encoded_size(x.package_directory, 1))
    !isempty(x.destination_directory) && (encoded_size += PB._encoded_size(x.destination_directory, 2))
    return encoded_size
end

struct DependencyInfo
    name::String
    version::String
end
PB.default_values(::Type{DependencyInfo}) = (;name = "", version = "")
PB.field_numbers(::Type{DependencyInfo}) = (;name = 1, version = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DependencyInfo})
    name = ""
    version = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            version = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return DependencyInfo(name, version)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DependencyInfo)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.version) && PB.encode(e, 2, x.version)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DependencyInfo)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.version) && (encoded_size += PB._encoded_size(x.version, 2))
    return encoded_size
end

struct GenerateProgramResponse
    diagnostics::Vector{pulumirpc.codegen.Diagnostic}
    source::Dict{String,Vector{UInt8}}
end
PB.default_values(::Type{GenerateProgramResponse}) = (;diagnostics = Vector{pulumirpc.codegen.Diagnostic}(), source = Dict{String,Vector{UInt8}}())
PB.field_numbers(::Type{GenerateProgramResponse}) = (;diagnostics = 1, source = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GenerateProgramResponse})
    diagnostics = PB.BufferedVector{pulumirpc.codegen.Diagnostic}()
    source = Dict{String,Vector{UInt8}}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, diagnostics)
        elseif field_number == 2
            PB.decode!(d, source)
        else
            Base.skip(d, wire_type)
        end
    end
    return GenerateProgramResponse(diagnostics[], source)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GenerateProgramResponse)
    initpos = position(e.io)
    !isempty(x.diagnostics) && PB.encode(e, 1, x.diagnostics)
    !isempty(x.source) && PB.encode(e, 2, x.source)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GenerateProgramResponse)
    encoded_size = 0
    !isempty(x.diagnostics) && (encoded_size += PB._encoded_size(x.diagnostics, 1))
    !isempty(x.source) && (encoded_size += PB._encoded_size(x.source, 2))
    return encoded_size
end

struct GetRequiredPluginsResponse
    plugins::Vector{PluginDependency}
end
PB.default_values(::Type{GetRequiredPluginsResponse}) = (;plugins = Vector{PluginDependency}())
PB.field_numbers(::Type{GetRequiredPluginsResponse}) = (;plugins = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetRequiredPluginsResponse})
    plugins = PB.BufferedVector{PluginDependency}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, plugins)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetRequiredPluginsResponse(plugins[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetRequiredPluginsResponse)
    initpos = position(e.io)
    !isempty(x.plugins) && PB.encode(e, 1, x.plugins)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetRequiredPluginsResponse)
    encoded_size = 0
    !isempty(x.plugins) && (encoded_size += PB._encoded_size(x.plugins, 1))
    return encoded_size
end

struct GenerateProgramRequest
    source::Dict{String,String}
    loader_target::String
    strict::Bool
end
PB.default_values(::Type{GenerateProgramRequest}) = (;source = Dict{String,String}(), loader_target = "", strict = false)
PB.field_numbers(::Type{GenerateProgramRequest}) = (;source = 1, loader_target = 2, strict = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GenerateProgramRequest})
    source = Dict{String,String}()
    loader_target = ""
    strict = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, source)
        elseif field_number == 2
            loader_target = PB.decode(d, String)
        elseif field_number == 3
            strict = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return GenerateProgramRequest(source, loader_target, strict)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GenerateProgramRequest)
    initpos = position(e.io)
    !isempty(x.source) && PB.encode(e, 1, x.source)
    !isempty(x.loader_target) && PB.encode(e, 2, x.loader_target)
    x.strict != false && PB.encode(e, 3, x.strict)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GenerateProgramRequest)
    encoded_size = 0
    !isempty(x.source) && (encoded_size += PB._encoded_size(x.source, 1))
    !isempty(x.loader_target) && (encoded_size += PB._encoded_size(x.loader_target, 2))
    x.strict != false && (encoded_size += PB._encoded_size(x.strict, 3))
    return encoded_size
end

struct var"LinkRequest.LinkDependency"
    package::Union{Nothing,PackageDependency}
    path::String
end
PB.default_values(::Type{var"LinkRequest.LinkDependency"}) = (;package = nothing, path = "")
PB.field_numbers(::Type{var"LinkRequest.LinkDependency"}) = (;package = 1, path = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"LinkRequest.LinkDependency"})
    package = Ref{Union{Nothing,PackageDependency}}(nothing)
    path = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, package)
        elseif field_number == 2
            path = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"LinkRequest.LinkDependency"(package[], path)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"LinkRequest.LinkDependency")
    initpos = position(e.io)
    !isnothing(x.package) && PB.encode(e, 1, x.package)
    !isempty(x.path) && PB.encode(e, 2, x.path)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"LinkRequest.LinkDependency")
    encoded_size = 0
    !isnothing(x.package) && (encoded_size += PB._encoded_size(x.package, 1))
    !isempty(x.path) && (encoded_size += PB._encoded_size(x.path, 2))
    return encoded_size
end

struct GetProgramDependenciesRequest
    project::String
    pwd::String
    program::String
    transitiveDependencies::Bool
    info::Union{Nothing,ProgramInfo}
end
PB.default_values(::Type{GetProgramDependenciesRequest}) = (;project = "", pwd = "", program = "", transitiveDependencies = false, info = nothing)
PB.field_numbers(::Type{GetProgramDependenciesRequest}) = (;project = 1, pwd = 2, program = 3, transitiveDependencies = 4, info = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetProgramDependenciesRequest})
    project = ""
    pwd = ""
    program = ""
    transitiveDependencies = false
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            project = PB.decode(d, String)
        elseif field_number == 2
            pwd = PB.decode(d, String)
        elseif field_number == 3
            program = PB.decode(d, String)
        elseif field_number == 4
            transitiveDependencies = PB.decode(d, Bool)
        elseif field_number == 5
            PB.decode!(d, info)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetProgramDependenciesRequest(project, pwd, program, transitiveDependencies, info[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetProgramDependenciesRequest)
    initpos = position(e.io)
    !isempty(x.project) && PB.encode(e, 1, x.project)
    !isempty(x.pwd) && PB.encode(e, 2, x.pwd)
    !isempty(x.program) && PB.encode(e, 3, x.program)
    x.transitiveDependencies != false && PB.encode(e, 4, x.transitiveDependencies)
    !isnothing(x.info) && PB.encode(e, 5, x.info)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetProgramDependenciesRequest)
    encoded_size = 0
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 1))
    !isempty(x.pwd) && (encoded_size += PB._encoded_size(x.pwd, 2))
    !isempty(x.program) && (encoded_size += PB._encoded_size(x.program, 3))
    x.transitiveDependencies != false && (encoded_size += PB._encoded_size(x.transitiveDependencies, 4))
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 5))
    return encoded_size
end

struct RuntimeOptionsRequest
    info::Union{Nothing,ProgramInfo}
end
PB.default_values(::Type{RuntimeOptionsRequest}) = (;info = nothing)
PB.field_numbers(::Type{RuntimeOptionsRequest}) = (;info = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RuntimeOptionsRequest})
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, info)
        else
            Base.skip(d, wire_type)
        end
    end
    return RuntimeOptionsRequest(info[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RuntimeOptionsRequest)
    initpos = position(e.io)
    !isnothing(x.info) && PB.encode(e, 1, x.info)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RuntimeOptionsRequest)
    encoded_size = 0
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 1))
    return encoded_size
end

struct TemplateRequest
    info::Union{Nothing,ProgramInfo}
    project_name::String
end
PB.default_values(::Type{TemplateRequest}) = (;info = nothing, project_name = "")
PB.field_numbers(::Type{TemplateRequest}) = (;info = 1, project_name = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TemplateRequest})
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    project_name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, info)
        elseif field_number == 2
            project_name = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return TemplateRequest(info[], project_name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TemplateRequest)
    initpos = position(e.io)
    !isnothing(x.info) && PB.encode(e, 1, x.info)
    !isempty(x.project_name) && PB.encode(e, 2, x.project_name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TemplateRequest)
    encoded_size = 0
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 1))
    !isempty(x.project_name) && (encoded_size += PB._encoded_size(x.project_name, 2))
    return encoded_size
end

struct GetRequiredPluginsRequest
    project::String
    pwd::String
    program::String
    info::Union{Nothing,ProgramInfo}
end
PB.default_values(::Type{GetRequiredPluginsRequest}) = (;project = "", pwd = "", program = "", info = nothing)
PB.field_numbers(::Type{GetRequiredPluginsRequest}) = (;project = 1, pwd = 2, program = 3, info = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetRequiredPluginsRequest})
    project = ""
    pwd = ""
    program = ""
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            project = PB.decode(d, String)
        elseif field_number == 2
            pwd = PB.decode(d, String)
        elseif field_number == 3
            program = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, info)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetRequiredPluginsRequest(project, pwd, program, info[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetRequiredPluginsRequest)
    initpos = position(e.io)
    !isempty(x.project) && PB.encode(e, 1, x.project)
    !isempty(x.pwd) && PB.encode(e, 2, x.pwd)
    !isempty(x.program) && PB.encode(e, 3, x.program)
    !isnothing(x.info) && PB.encode(e, 4, x.info)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetRequiredPluginsRequest)
    encoded_size = 0
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 1))
    !isempty(x.pwd) && (encoded_size += PB._encoded_size(x.pwd, 2))
    !isempty(x.program) && (encoded_size += PB._encoded_size(x.program, 3))
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 4))
    return encoded_size
end

struct RunRequest
    project::String
    stack::String
    pwd::String
    program::String
    args::Vector{String}
    config::Dict{String,String}
    dryRun::Bool
    parallel::Int32
    monitor_address::String
    queryMode::Bool
    configSecretKeys::Vector{String}
    organization::String
    configPropertyMap::Union{Nothing,google.protobuf.Struct}
    info::Union{Nothing,ProgramInfo}
    loader_target::String
    attach_debugger::Bool
end
PB.default_values(::Type{RunRequest}) = (;project = "", stack = "", pwd = "", program = "", args = Vector{String}(), config = Dict{String,String}(), dryRun = false, parallel = zero(Int32), monitor_address = "", queryMode = false, configSecretKeys = Vector{String}(), organization = "", configPropertyMap = nothing, info = nothing, loader_target = "", attach_debugger = false)
PB.field_numbers(::Type{RunRequest}) = (;project = 1, stack = 2, pwd = 3, program = 4, args = 5, config = 6, dryRun = 7, parallel = 8, monitor_address = 9, queryMode = 10, configSecretKeys = 11, organization = 12, configPropertyMap = 13, info = 14, loader_target = 15, attach_debugger = 16)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RunRequest})
    project = ""
    stack = ""
    pwd = ""
    program = ""
    args = PB.BufferedVector{String}()
    config = Dict{String,String}()
    dryRun = false
    parallel = zero(Int32)
    monitor_address = ""
    queryMode = false
    configSecretKeys = PB.BufferedVector{String}()
    organization = ""
    configPropertyMap = Ref{Union{Nothing,google.protobuf.Struct}}(nothing)
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    loader_target = ""
    attach_debugger = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            project = PB.decode(d, String)
        elseif field_number == 2
            stack = PB.decode(d, String)
        elseif field_number == 3
            pwd = PB.decode(d, String)
        elseif field_number == 4
            program = PB.decode(d, String)
        elseif field_number == 5
            PB.decode!(d, args)
        elseif field_number == 6
            PB.decode!(d, config)
        elseif field_number == 7
            dryRun = PB.decode(d, Bool)
        elseif field_number == 8
            parallel = PB.decode(d, Int32)
        elseif field_number == 9
            monitor_address = PB.decode(d, String)
        elseif field_number == 10
            queryMode = PB.decode(d, Bool)
        elseif field_number == 11
            PB.decode!(d, configSecretKeys)
        elseif field_number == 12
            organization = PB.decode(d, String)
        elseif field_number == 13
            PB.decode!(d, configPropertyMap)
        elseif field_number == 14
            PB.decode!(d, info)
        elseif field_number == 15
            loader_target = PB.decode(d, String)
        elseif field_number == 16
            attach_debugger = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return RunRequest(project, stack, pwd, program, args[], config, dryRun, parallel, monitor_address, queryMode, configSecretKeys[], organization, configPropertyMap[], info[], loader_target, attach_debugger)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RunRequest)
    initpos = position(e.io)
    !isempty(x.project) && PB.encode(e, 1, x.project)
    !isempty(x.stack) && PB.encode(e, 2, x.stack)
    !isempty(x.pwd) && PB.encode(e, 3, x.pwd)
    !isempty(x.program) && PB.encode(e, 4, x.program)
    !isempty(x.args) && PB.encode(e, 5, x.args)
    !isempty(x.config) && PB.encode(e, 6, x.config)
    x.dryRun != false && PB.encode(e, 7, x.dryRun)
    x.parallel != zero(Int32) && PB.encode(e, 8, x.parallel)
    !isempty(x.monitor_address) && PB.encode(e, 9, x.monitor_address)
    x.queryMode != false && PB.encode(e, 10, x.queryMode)
    !isempty(x.configSecretKeys) && PB.encode(e, 11, x.configSecretKeys)
    !isempty(x.organization) && PB.encode(e, 12, x.organization)
    !isnothing(x.configPropertyMap) && PB.encode(e, 13, x.configPropertyMap)
    !isnothing(x.info) && PB.encode(e, 14, x.info)
    !isempty(x.loader_target) && PB.encode(e, 15, x.loader_target)
    x.attach_debugger != false && PB.encode(e, 16, x.attach_debugger)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RunRequest)
    encoded_size = 0
    !isempty(x.project) && (encoded_size += PB._encoded_size(x.project, 1))
    !isempty(x.stack) && (encoded_size += PB._encoded_size(x.stack, 2))
    !isempty(x.pwd) && (encoded_size += PB._encoded_size(x.pwd, 3))
    !isempty(x.program) && (encoded_size += PB._encoded_size(x.program, 4))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 5))
    !isempty(x.config) && (encoded_size += PB._encoded_size(x.config, 6))
    x.dryRun != false && (encoded_size += PB._encoded_size(x.dryRun, 7))
    x.parallel != zero(Int32) && (encoded_size += PB._encoded_size(x.parallel, 8))
    !isempty(x.monitor_address) && (encoded_size += PB._encoded_size(x.monitor_address, 9))
    x.queryMode != false && (encoded_size += PB._encoded_size(x.queryMode, 10))
    !isempty(x.configSecretKeys) && (encoded_size += PB._encoded_size(x.configSecretKeys, 11))
    !isempty(x.organization) && (encoded_size += PB._encoded_size(x.organization, 12))
    !isnothing(x.configPropertyMap) && (encoded_size += PB._encoded_size(x.configPropertyMap, 13))
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 14))
    !isempty(x.loader_target) && (encoded_size += PB._encoded_size(x.loader_target, 15))
    x.attach_debugger != false && (encoded_size += PB._encoded_size(x.attach_debugger, 16))
    return encoded_size
end

struct InstallDependenciesRequest
    directory::String
    is_terminal::Bool
    info::Union{Nothing,ProgramInfo}
    use_language_version_tools::Bool
    is_plugin::Bool
end
PB.default_values(::Type{InstallDependenciesRequest}) = (;directory = "", is_terminal = false, info = nothing, use_language_version_tools = false, is_plugin = false)
PB.field_numbers(::Type{InstallDependenciesRequest}) = (;directory = 1, is_terminal = 2, info = 3, use_language_version_tools = 4, is_plugin = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InstallDependenciesRequest})
    directory = ""
    is_terminal = false
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    use_language_version_tools = false
    is_plugin = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            directory = PB.decode(d, String)
        elseif field_number == 2
            is_terminal = PB.decode(d, Bool)
        elseif field_number == 3
            PB.decode!(d, info)
        elseif field_number == 4
            use_language_version_tools = PB.decode(d, Bool)
        elseif field_number == 5
            is_plugin = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return InstallDependenciesRequest(directory, is_terminal, info[], use_language_version_tools, is_plugin)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InstallDependenciesRequest)
    initpos = position(e.io)
    !isempty(x.directory) && PB.encode(e, 1, x.directory)
    x.is_terminal != false && PB.encode(e, 2, x.is_terminal)
    !isnothing(x.info) && PB.encode(e, 3, x.info)
    x.use_language_version_tools != false && PB.encode(e, 4, x.use_language_version_tools)
    x.is_plugin != false && PB.encode(e, 5, x.is_plugin)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InstallDependenciesRequest)
    encoded_size = 0
    !isempty(x.directory) && (encoded_size += PB._encoded_size(x.directory, 1))
    x.is_terminal != false && (encoded_size += PB._encoded_size(x.is_terminal, 2))
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 3))
    x.use_language_version_tools != false && (encoded_size += PB._encoded_size(x.use_language_version_tools, 4))
    x.is_plugin != false && (encoded_size += PB._encoded_size(x.is_plugin, 5))
    return encoded_size
end

struct RunPluginRequest
    pwd::String
    program::String
    args::Vector{String}
    env::Vector{String}
    info::Union{Nothing,ProgramInfo}
    kind::String
    name::String
    attach_debugger::Bool
end
PB.default_values(::Type{RunPluginRequest}) = (;pwd = "", program = "", args = Vector{String}(), env = Vector{String}(), info = nothing, kind = "", name = "", attach_debugger = false)
PB.field_numbers(::Type{RunPluginRequest}) = (;pwd = 1, program = 2, args = 3, env = 4, info = 5, kind = 6, name = 7, attach_debugger = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RunPluginRequest})
    pwd = ""
    program = ""
    args = PB.BufferedVector{String}()
    env = PB.BufferedVector{String}()
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    kind = ""
    name = ""
    attach_debugger = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            pwd = PB.decode(d, String)
        elseif field_number == 2
            program = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, args)
        elseif field_number == 4
            PB.decode!(d, env)
        elseif field_number == 5
            PB.decode!(d, info)
        elseif field_number == 6
            kind = PB.decode(d, String)
        elseif field_number == 7
            name = PB.decode(d, String)
        elseif field_number == 8
            attach_debugger = PB.decode(d, Bool)
        else
            Base.skip(d, wire_type)
        end
    end
    return RunPluginRequest(pwd, program, args[], env[], info[], kind, name, attach_debugger)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RunPluginRequest)
    initpos = position(e.io)
    !isempty(x.pwd) && PB.encode(e, 1, x.pwd)
    !isempty(x.program) && PB.encode(e, 2, x.program)
    !isempty(x.args) && PB.encode(e, 3, x.args)
    !isempty(x.env) && PB.encode(e, 4, x.env)
    !isnothing(x.info) && PB.encode(e, 5, x.info)
    !isempty(x.kind) && PB.encode(e, 6, x.kind)
    !isempty(x.name) && PB.encode(e, 7, x.name)
    x.attach_debugger != false && PB.encode(e, 8, x.attach_debugger)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RunPluginRequest)
    encoded_size = 0
    !isempty(x.pwd) && (encoded_size += PB._encoded_size(x.pwd, 1))
    !isempty(x.program) && (encoded_size += PB._encoded_size(x.program, 2))
    !isempty(x.args) && (encoded_size += PB._encoded_size(x.args, 3))
    !isempty(x.env) && (encoded_size += PB._encoded_size(x.env, 4))
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 5))
    !isempty(x.kind) && (encoded_size += PB._encoded_size(x.kind, 6))
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 7))
    x.attach_debugger != false && (encoded_size += PB._encoded_size(x.attach_debugger, 8))
    return encoded_size
end

struct AboutRequest
    info::Union{Nothing,ProgramInfo}
end
PB.default_values(::Type{AboutRequest}) = (;info = nothing)
PB.field_numbers(::Type{AboutRequest}) = (;info = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AboutRequest})
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, info)
        else
            Base.skip(d, wire_type)
        end
    end
    return AboutRequest(info[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AboutRequest)
    initpos = position(e.io)
    !isnothing(x.info) && PB.encode(e, 1, x.info)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AboutRequest)
    encoded_size = 0
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 1))
    return encoded_size
end

struct GetRequiredPackagesRequest
    info::Union{Nothing,ProgramInfo}
end
PB.default_values(::Type{GetRequiredPackagesRequest}) = (;info = nothing)
PB.field_numbers(::Type{GetRequiredPackagesRequest}) = (;info = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetRequiredPackagesRequest})
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, info)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetRequiredPackagesRequest(info[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetRequiredPackagesRequest)
    initpos = position(e.io)
    !isnothing(x.info) && PB.encode(e, 1, x.info)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetRequiredPackagesRequest)
    encoded_size = 0
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 1))
    return encoded_size
end

struct var"RuntimeOptionPrompt.RuntimeOptionValue"
    promptType::var"RuntimeOptionPrompt.RuntimeOptionType".T
    stringValue::String
    int32Value::Int32
    displayName::String
end
PB.default_values(::Type{var"RuntimeOptionPrompt.RuntimeOptionValue"}) = (;promptType = var"RuntimeOptionPrompt.RuntimeOptionType".STRING, stringValue = "", int32Value = zero(Int32), displayName = "")
PB.field_numbers(::Type{var"RuntimeOptionPrompt.RuntimeOptionValue"}) = (;promptType = 1, stringValue = 2, int32Value = 3, displayName = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"RuntimeOptionPrompt.RuntimeOptionValue"})
    promptType = var"RuntimeOptionPrompt.RuntimeOptionType".STRING
    stringValue = ""
    int32Value = zero(Int32)
    displayName = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            promptType = PB.decode(d, var"RuntimeOptionPrompt.RuntimeOptionType".T)
        elseif field_number == 2
            stringValue = PB.decode(d, String)
        elseif field_number == 3
            int32Value = PB.decode(d, Int32)
        elseif field_number == 4
            displayName = PB.decode(d, String)
        else
            Base.skip(d, wire_type)
        end
    end
    return var"RuntimeOptionPrompt.RuntimeOptionValue"(promptType, stringValue, int32Value, displayName)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"RuntimeOptionPrompt.RuntimeOptionValue")
    initpos = position(e.io)
    x.promptType != var"RuntimeOptionPrompt.RuntimeOptionType".STRING && PB.encode(e, 1, x.promptType)
    !isempty(x.stringValue) && PB.encode(e, 2, x.stringValue)
    x.int32Value != zero(Int32) && PB.encode(e, 3, x.int32Value)
    !isempty(x.displayName) && PB.encode(e, 4, x.displayName)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"RuntimeOptionPrompt.RuntimeOptionValue")
    encoded_size = 0
    x.promptType != var"RuntimeOptionPrompt.RuntimeOptionType".STRING && (encoded_size += PB._encoded_size(x.promptType, 1))
    !isempty(x.stringValue) && (encoded_size += PB._encoded_size(x.stringValue, 2))
    x.int32Value != zero(Int32) && (encoded_size += PB._encoded_size(x.int32Value, 3))
    !isempty(x.displayName) && (encoded_size += PB._encoded_size(x.displayName, 4))
    return encoded_size
end

struct GetProgramDependenciesResponse
    dependencies::Vector{DependencyInfo}
end
PB.default_values(::Type{GetProgramDependenciesResponse}) = (;dependencies = Vector{DependencyInfo}())
PB.field_numbers(::Type{GetProgramDependenciesResponse}) = (;dependencies = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GetProgramDependenciesResponse})
    dependencies = PB.BufferedVector{DependencyInfo}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, dependencies)
        else
            Base.skip(d, wire_type)
        end
    end
    return GetProgramDependenciesResponse(dependencies[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GetProgramDependenciesResponse)
    initpos = position(e.io)
    !isempty(x.dependencies) && PB.encode(e, 1, x.dependencies)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GetProgramDependenciesResponse)
    encoded_size = 0
    !isempty(x.dependencies) && (encoded_size += PB._encoded_size(x.dependencies, 1))
    return encoded_size
end

struct LinkRequest
    info::Union{Nothing,ProgramInfo}
    loader_target::String
    packages::Vector{var"LinkRequest.LinkDependency"}
end
PB.default_values(::Type{LinkRequest}) = (;info = nothing, loader_target = "", packages = Vector{var"LinkRequest.LinkDependency"}())
PB.field_numbers(::Type{LinkRequest}) = (;info = 1, loader_target = 2, packages = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinkRequest})
    info = Ref{Union{Nothing,ProgramInfo}}(nothing)
    loader_target = ""
    packages = PB.BufferedVector{var"LinkRequest.LinkDependency"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, info)
        elseif field_number == 2
            loader_target = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, packages)
        else
            Base.skip(d, wire_type)
        end
    end
    return LinkRequest(info[], loader_target, packages[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinkRequest)
    initpos = position(e.io)
    !isnothing(x.info) && PB.encode(e, 1, x.info)
    !isempty(x.loader_target) && PB.encode(e, 2, x.loader_target)
    !isempty(x.packages) && PB.encode(e, 3, x.packages)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinkRequest)
    encoded_size = 0
    !isnothing(x.info) && (encoded_size += PB._encoded_size(x.info, 1))
    !isempty(x.loader_target) && (encoded_size += PB._encoded_size(x.loader_target, 2))
    !isempty(x.packages) && (encoded_size += PB._encoded_size(x.packages, 3))
    return encoded_size
end

struct RuntimeOptionPrompt
    key::String
    description::String
    promptType::var"RuntimeOptionPrompt.RuntimeOptionType".T
    choices::Vector{var"RuntimeOptionPrompt.RuntimeOptionValue"}
    default::Union{Nothing,var"RuntimeOptionPrompt.RuntimeOptionValue"}
end
PB.default_values(::Type{RuntimeOptionPrompt}) = (;key = "", description = "", promptType = var"RuntimeOptionPrompt.RuntimeOptionType".STRING, choices = Vector{var"RuntimeOptionPrompt.RuntimeOptionValue"}(), default = nothing)
PB.field_numbers(::Type{RuntimeOptionPrompt}) = (;key = 1, description = 2, promptType = 3, choices = 4, default = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RuntimeOptionPrompt})
    key = ""
    description = ""
    promptType = var"RuntimeOptionPrompt.RuntimeOptionType".STRING
    choices = PB.BufferedVector{var"RuntimeOptionPrompt.RuntimeOptionValue"}()
    default = Ref{Union{Nothing,var"RuntimeOptionPrompt.RuntimeOptionValue"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            key = PB.decode(d, String)
        elseif field_number == 2
            description = PB.decode(d, String)
        elseif field_number == 3
            promptType = PB.decode(d, var"RuntimeOptionPrompt.RuntimeOptionType".T)
        elseif field_number == 4
            PB.decode!(d, choices)
        elseif field_number == 5
            PB.decode!(d, default)
        else
            Base.skip(d, wire_type)
        end
    end
    return RuntimeOptionPrompt(key, description, promptType, choices[], default[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RuntimeOptionPrompt)
    initpos = position(e.io)
    !isempty(x.key) && PB.encode(e, 1, x.key)
    !isempty(x.description) && PB.encode(e, 2, x.description)
    x.promptType != var"RuntimeOptionPrompt.RuntimeOptionType".STRING && PB.encode(e, 3, x.promptType)
    !isempty(x.choices) && PB.encode(e, 4, x.choices)
    !isnothing(x.default) && PB.encode(e, 5, x.default)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RuntimeOptionPrompt)
    encoded_size = 0
    !isempty(x.key) && (encoded_size += PB._encoded_size(x.key, 1))
    !isempty(x.description) && (encoded_size += PB._encoded_size(x.description, 2))
    x.promptType != var"RuntimeOptionPrompt.RuntimeOptionType".STRING && (encoded_size += PB._encoded_size(x.promptType, 3))
    !isempty(x.choices) && (encoded_size += PB._encoded_size(x.choices, 4))
    !isnothing(x.default) && (encoded_size += PB._encoded_size(x.default, 5))
    return encoded_size
end

struct RuntimeOptionsResponse
    prompts::Vector{RuntimeOptionPrompt}
end
PB.default_values(::Type{RuntimeOptionsResponse}) = (;prompts = Vector{RuntimeOptionPrompt}())
PB.field_numbers(::Type{RuntimeOptionsResponse}) = (;prompts = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RuntimeOptionsResponse})
    prompts = PB.BufferedVector{RuntimeOptionPrompt}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, prompts)
        else
            Base.skip(d, wire_type)
        end
    end
    return RuntimeOptionsResponse(prompts[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RuntimeOptionsResponse)
    initpos = position(e.io)
    !isempty(x.prompts) && PB.encode(e, 1, x.prompts)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RuntimeOptionsResponse)
    encoded_size = 0
    !isempty(x.prompts) && (encoded_size += PB._encoded_size(x.prompts, 1))
    return encoded_size
end

# TODO: SERVICE
#    LanguageRuntime
