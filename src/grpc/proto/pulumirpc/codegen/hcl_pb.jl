# Autogenerated using ProtoBuf.jl v1.2.0 on 2026-01-10T11:38:24.595
# original file: /home/scelles-admin/.julia/artifacts/c90104a6945c9e4b68315984a83d31d012ee8abc/pulumi/codegen/hcl.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export Pos, DiagnosticSeverity, Range, Diagnostic


struct Pos
    line::Int64
    column::Int64
    byte::Int64
end
PB.default_values(::Type{Pos}) = (;line = zero(Int64), column = zero(Int64), byte = zero(Int64))
PB.field_numbers(::Type{Pos}) = (;line = 1, column = 2, byte = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Pos})
    line = zero(Int64)
    column = zero(Int64)
    byte = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            line = PB.decode(d, Int64)
        elseif field_number == 2
            column = PB.decode(d, Int64)
        elseif field_number == 3
            byte = PB.decode(d, Int64)
        else
            Base.skip(d, wire_type)
        end
    end
    return Pos(line, column, byte)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Pos)
    initpos = position(e.io)
    x.line != zero(Int64) && PB.encode(e, 1, x.line)
    x.column != zero(Int64) && PB.encode(e, 2, x.column)
    x.byte != zero(Int64) && PB.encode(e, 3, x.byte)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Pos)
    encoded_size = 0
    x.line != zero(Int64) && (encoded_size += PB._encoded_size(x.line, 1))
    x.column != zero(Int64) && (encoded_size += PB._encoded_size(x.column, 2))
    x.byte != zero(Int64) && (encoded_size += PB._encoded_size(x.byte, 3))
    return encoded_size
end

@enumx DiagnosticSeverity DIAG_INVALID=0 DIAG_ERROR=1 DIAG_WARNING=2

struct Range
    filename::String
    start::Union{Nothing,Pos}
    var"#end"::Union{Nothing,Pos}
end
PB.default_values(::Type{Range}) = (;filename = "", start = nothing, var"#end" = nothing)
PB.field_numbers(::Type{Range}) = (;filename = 1, start = 2, var"#end" = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Range})
    filename = ""
    start = Ref{Union{Nothing,Pos}}(nothing)
    var"#end" = Ref{Union{Nothing,Pos}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            filename = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, start)
        elseif field_number == 3
            PB.decode!(d, var"#end")
        else
            Base.skip(d, wire_type)
        end
    end
    return Range(filename, start[], var"#end"[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Range)
    initpos = position(e.io)
    !isempty(x.filename) && PB.encode(e, 1, x.filename)
    !isnothing(x.start) && PB.encode(e, 2, x.start)
    !isnothing(x.var"#end") && PB.encode(e, 3, x.var"#end")
    return position(e.io) - initpos
end
function PB._encoded_size(x::Range)
    encoded_size = 0
    !isempty(x.filename) && (encoded_size += PB._encoded_size(x.filename, 1))
    !isnothing(x.start) && (encoded_size += PB._encoded_size(x.start, 2))
    !isnothing(x.var"#end") && (encoded_size += PB._encoded_size(x.var"#end", 3))
    return encoded_size
end

struct Diagnostic
    severity::DiagnosticSeverity.T
    summary::String
    detail::String
    subject::Union{Nothing,Range}
    context::Union{Nothing,Range}
end
PB.default_values(::Type{Diagnostic}) = (;severity = DiagnosticSeverity.DIAG_INVALID, summary = "", detail = "", subject = nothing, context = nothing)
PB.field_numbers(::Type{Diagnostic}) = (;severity = 1, summary = 2, detail = 3, subject = 4, context = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Diagnostic})
    severity = DiagnosticSeverity.DIAG_INVALID
    summary = ""
    detail = ""
    subject = Ref{Union{Nothing,Range}}(nothing)
    context = Ref{Union{Nothing,Range}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            severity = PB.decode(d, DiagnosticSeverity.T)
        elseif field_number == 2
            summary = PB.decode(d, String)
        elseif field_number == 3
            detail = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, subject)
        elseif field_number == 5
            PB.decode!(d, context)
        else
            Base.skip(d, wire_type)
        end
    end
    return Diagnostic(severity, summary, detail, subject[], context[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Diagnostic)
    initpos = position(e.io)
    x.severity != DiagnosticSeverity.DIAG_INVALID && PB.encode(e, 1, x.severity)
    !isempty(x.summary) && PB.encode(e, 2, x.summary)
    !isempty(x.detail) && PB.encode(e, 3, x.detail)
    !isnothing(x.subject) && PB.encode(e, 4, x.subject)
    !isnothing(x.context) && PB.encode(e, 5, x.context)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Diagnostic)
    encoded_size = 0
    x.severity != DiagnosticSeverity.DIAG_INVALID && (encoded_size += PB._encoded_size(x.severity, 1))
    !isempty(x.summary) && (encoded_size += PB._encoded_size(x.summary, 2))
    !isempty(x.detail) && (encoded_size += PB._encoded_size(x.detail, 3))
    !isnothing(x.subject) && (encoded_size += PB._encoded_size(x.subject, 4))
    !isnothing(x.context) && (encoded_size += PB._encoded_size(x.context, 5))
    return encoded_size
end
